### Step 1: Create Namespace for users
```
kubectl create namespace nithya-namespace
```
### Step 2: Create a ServiceAccount for "User" in that namespace
```
kubectl create serviceaccount nithya -n nithya-namespace
```
### Step 3:Deploy pods

1.postgres-deployment
```
nano postgres-deployment.yaml
```
```
apiVersion: v1
kind: Service
metadata:
  name: postgres
  namespace: nithya-namespace
spec:
  type: ClusterIP
  ports:
    - port: 5432
  selector:
    app: postgres
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: postgres
  namespace: nithya-namespace
spec:
  replicas: 1
  selector:
    matchLabels:
      app: postgres
  template:
    metadata:
      labels:
        app: postgres
    spec:
      containers:
        - name: postgres
          image: postgres:13
          env:
            - name: POSTGRES_DB
              value: jasperdb
            - name: POSTGRES_USER
              value: jasper
            - name: POSTGRES_PASSWORD
              value: jasper123
          ports:
            - containerPort: 5432

```
Apply it.
```
kubectl apply -f postgres-deployment.yaml
```
2.jasper report server

```
nano jasper-deployment.yaml
```
```
apiVersion: v1
kind: Service
metadata:
  name: jasperreports
  namespace: nithya-namespace
spec:
  type: NodePort
  ports:
    - port: 8080
      targetPort: 8080
      nodePort: 30080
  selector:
    app: jasperreports
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: jasperreports
  namespace: nithya-namespace
spec:
  replicas: 1
  selector:
    matchLabels:
      app: jasperreports
  template:
    metadata:
      labels:
        app: jasperreports
    spec:
      containers:
        - name: jasperreports
          image: bitnami/jasperreports:latest
          ports:
            - containerPort: 8080
          env:
            - name: JASPERREPORTS_DATABASE_TYPE
              value: postgresql
            - name: JASPERREPORTS_DATABASE_HOST
              value: postgres
            - name: JASPERREPORTS_DATABASE_PORT_NUMBER
              value: "5432"
            - name: JASPERREPORTS_DATABASE_NAME
              value: jasperdb
            - name: JASPERREPORTS_DATABASE_USER
              value: jasper
            - name: JASPERREPORTS_DATABASE_PASSWORD
              value: jasper123
            - name: JASPERREPORTS_USERNAME
              value: jasperadmin
            - name: JASPERREPORTS_PASSWORD
              value: jasperadmin
```
Apply it
```
kubectl apply -f jasper-deployment.yaml
```
- Check pods running in specific namespace

![image](https://github.com/user-attachments/assets/9f21acd4-3f6c-4943-8d63-987ce4f10b00)

### Step 4:Create a Role for namespace access (pods, services, etc)

```
nano nithya-role.yaml
```
```
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  namespace: nithya-namespace
  name: pod-reader
rules:
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["get", "list", "watch"]

```
Apply it.
```
kubectl apply -f nithya-role.yaml
```
### Step 5: Bind the Role to User's ServiceAccount
```
nano nithya-rolebinding.yaml
```
```
kind: RoleBinding
metadata:
  name: nithya-rolebinding
  namespace: nithya-namespace
subjects:
- kind: ServiceAccount
  name: nithya
  namespace: nithya-namespace
  # apiGroup: rbac.authorization.k8s.io   <--- REMOVE THIS LINE
roleRef:
  kind: Role
  name: pod-reader
  apiGroup: rbac.authorization.k8s.io
```
Apply it.
```
kubectl apply -f nithya-rolebinding.yaml
```
### Step 6: Create kubeconfig file

#### By using this command, will automatically generate a kubeconfig file for our Azure Kubernetes Service (AKS) cluster:

- Connects to the AKS cluster test-cluster in resource group rg-ranjitha.

- Downloads the cluster credentials and writes them to ./kubeconfig-yaml.

- Sets the current context inside that file so you can run kubectl commands using it.
```
az aks get-credentials --resource-group <resoursegroup-name> --name <cluster-name> --file ./<kubeconfig-filename>
```
![image](https://github.com/user-attachments/assets/3f2c8e9c-0ca4-4aa7-b874-1a2df3cb3d61)

#### Auto-generated kubeconfig file looks like
```
apiVersion: v1
clusters:
- cluster:
    certificate-authority-data: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUU2VENDQXRHZ0F3SUJBZ0lSQU0wVXA2Q3M4QnlJSzU1TTU4YUhRM2d3RFFZSktvWklodmNOQVFFTEJRQXcKRFRFTE1Ba0dBMVVFQXhNQ1kyRXdJQmNOTWpVd05URTFNRFV6T1RRMl>
    server: https://test-cluster-dns-yh6r89d2.hcp.centralindia.azmk8s.io:443
  name: test-cluster
contexts:
- context:
    cluster: test-cluster
    user: clusterUser_rg-ranjitha_test-cluster
    namespace: nithya-namespace
  name: test-cluster
current-context: test-cluster
kind: Config
preferences: {}
users:
- name: clusterUser_rg-ranjitha_test-cluster
  user:
    client-certificate-data: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUZIVENDQXdXZ0F3SUJBZ0lRWkptUWQvbTNjTzV1bk1RQnZhWThKREFOQmdrcWhraUc5dzBCQVFzRkFEQU4KTVFzd0NRWURWUVFERXdKallUQWVGdzB5TlRBMU1UVXdOVE01TkRaYUZ3M>
    client-key-data: LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlKS1FJQkFBS0NBZ0VBLzFFVmZWTjlndEJTdFN0aFRGbUgvdlpBZjRWNXZkbnQxbmxKMXdHOHA4eUp6NnpRCmV3ZHdVOXdOT2ZDWFJFenFSRTNhb3ZxaGpqVU9PblIybk1NTk8wU2pmWnM3Y>
    token: ojk466aijnikb50jhursz995cpm6hbsam1ip0m97u4plm7xmqpu4xiywg2fdkxjtmo3n86f5i1b7nd209fraqlczmz5ywf2jggtucayrd4tpupw8jokv0ukzvk6pmg2w
```
- Send the kubeconfig file to user.
- After Downloading user can access
```
KUBECONFIG=./<file-name> kubectl get pods
```
![image](https://github.com/user-attachments/assets/05c276f0-56b0-4cf2-8988-0f22fb6268b0)

