# Deploy 3-Tier Application in AKS

### Step 1 : Create cluster

- In portal search "Kubernetes services"

- Create > "kubernetes cluster"

![image](https://github.com/user-attachments/assets/00ffa18a-1052-402d-a588-ad29eb595146)
![image](https://github.com/user-attachments/assets/86b74638-196c-48db-ad59-f7a047dfb227)

**Next:Nodepools**

![image](https://github.com/user-attachments/assets/6bb07fc1-ff19-4a73-8341-b9c94655f782)

**Next:Networking**

- Public access ip:In browser check my ip

![image](https://github.com/user-attachments/assets/ffbb803d-ec9f-423f-90c9-b91d24ce4d9f)
![image](https://github.com/user-attachments/assets/dbd42219-846e-48f3-b80e-9a3cc8dbc9c9)

**Next:Integrations**

![image](https://github.com/user-attachments/assets/03e9d51a-83d2-4f9a-a202-6cfedce3e308)

**Next:Security**

- Enable keyvault to store secrets

![image](https://github.com/user-attachments/assets/8c1c6bff-50b4-45c6-a65d-9de02e562450)

**Review+create**

### Step 2: Create Azure mysql flexible server.

Add Database details in github secret

![image](https://github.com/user-attachments/assets/0d35c9f6-fe4c-45a9-ba99-f195dce1efa3)

### Step 3 :create Dockerfile.

- Check "ems-ops-phase" in current directory.

- Create Dockerfile for frontend in ems-ops-phase > react-hooks-frontend.

```
# Use the official Node.js image as a base
FROM --platform=linux/arm64 node:14-alpine

# Set the working directory inside the container
WORKDIR /app

# Copy package.json and package-lock.json files to the working directory
COPY package*.json ./

# Install dependencies
RUN npm install

# Copy the rest of the application code to the working directory
COPY . .

# Expose port 3000 for the application
EXPOSE 3000

# Command to run the application
CMD ["npm", "start"]
```
- docker build -t react .

----------------------------------------------------------------------------------------------------------------------------
**ERROR FACED**

![image](https://github.com/user-attachments/assets/f44871ed-7ab5-454d-8596-d0604e1f2cc0)


- Check Node Architecture via kubectl
```
kubectl get nodes -o wide
```
- Then to get the architecture specifically:
```
kubectl get nodes -o jsonpath="{range .items[*]}{@.metadata.name}:{@.status.nodeInfo.architecture}{'\n'}"
```
![image](https://github.com/user-attachments/assets/013754ba-0664-43f4-9ee0-93ab5fbd479d)

- AKS cluster nodes are arm64 architecture.So Dockerfile base image wants to supports arm64.(FROM --platform=linux/arm64 node:14-alpine)
---------------------------------------------------------------------------------------------------------------------------
 - Create dockerfile for backend in ems-ops-phase > springboot-backend
```
# Step 1: Use Maven to build the project
FROM maven:3.8.5-openjdk-17 AS build

WORKDIR /app

# Copy the project files to the container
COPY . .

# Build the application (without running tests)
RUN mvn clean package -DskipTests

# Step 2: Use a minimal Java runtime for the final image
FROM openjdk:17-jdk-slim

WORKDIR /app

# Copy the built JAR file from the Maven stage
COPY --from=build /app/target/springboot-backend-0.0.1-SNAPSHOT.jar /app/springboot-backend.jar

# Expose the application port
EXPOSE 8080

# Run the application
ENTRYPOINT ["java", "-jar", "/app/springboot-backend.jar"]
```
- docker build -t spring .
- docker images

### Step 4:push image to container registry.

[Refer](https://github.com/Ranjitha75388/projects/edit/main/Azure/12%20.%20Container%20app%20.md)

- Add details in github secrets. AZURE_CLIENT_ID , AZURE_TENANT_ID , AZURE_SUBSCRIPTION_ID , ACR_NAME , REGISTRY_USERNAME , REGISTRY_PASSWORD 

- Clone git repo "githubactions".

- cd ranjitha > githubactions > .github > workflows > nano aks.yaml
```
name: Build & Push to AKS

on:
  push:
    branches:
      - main

permissions:
  id-token: write
  contents: read

jobs:
  build-and-push:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout Repository
      uses: actions/checkout@v3

    # Login to Azure
    - name: Login to Azure
      uses: azure/login@v1
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

    # Login to Azure Container Registry (ACR)
    - name: Docker Login to ACR
      uses: docker/login-action@v3
      with:
        registry: ${{ secrets.ACR_NAME }}.azurecr.io
        username: ${{ secrets.REGISTRY_USERNAME }}
        password: ${{ secrets.REGISTRY_PASSWORD }}

    # Add this step *before* the docker/build-push-action
    - name: Set up QEMU
      uses: docker/setup-qemu-action@v3


    # ✅ Build and Push Frontend Image for arm64
    - name: Build and Push Frontend
      uses: docker/build-push-action@v5
      with:
        context: ./react-hooks-frontend
        push: true
        tags: ${{ secrets.ACR_NAME }}.azurecr.io/frontend:latest
        platforms: linux/arm64

    # ✅ Build and Push Backend Image for arm64 with DB build args
    - name: Build and Push Backend
      uses: docker/build-push-action@v5
      with:
        context: ./springboot-backend
        push: true
        tags: ${{ secrets.ACR_NAME }}.azurecr.io/backend:latest
        platforms: linux/arm64
        build-args: |
          DB_HOST=${{ secrets.DB_HOST }}
          DB_PORT=${{ secrets.DB_PORT }}
          DB_USER=${{ secrets.DB_USER }}
          DB_PASSWORD=${{ secrets.DB_PASSWORD }}
          DB_NAME=${{ secrets.DB_NAME }}

```
- cd githubactions --- gitadd . --- git commit -m "aks added" --- git push origin main

### step 5: Check image in container registry

container registry > Repositories 

![image](https://github.com/user-attachments/assets/f0ea859f-679f-4eab-ab8e-615291c22902)








- Clone git repo named "github-action" to current directory.
- cd 














Create Kubernetes Secret for DB Credentials

Use the values from Azure:

kubectl create secret generic db-secret \
  --from-literal=username='myuser@mydb' \
  --from-literal=password='yourpassword'
  
![image](https://github.com/user-attachments/assets/1af6850a-9927-4782-926c-bdf0ce59e005)

backend yaml
