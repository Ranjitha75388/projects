# Deploy 3-Tier Application in AKS

### Plan

1.  Create Azure kubernetes cluster.
2.  Create MYSQL flexible server.
3.  Need github repo to push image to ACR.
4.  Create container regisrty to pull image.
5.  Deploy frontend,backend yaml
6.  Check in browser. 


### Step 1 : Create cluster

- In portal search "Kubernetes services"

- Create > "kubernetes cluster"

![image](https://github.com/user-attachments/assets/00ffa18a-1052-402d-a588-ad29eb595146)
![image](https://github.com/user-attachments/assets/86b74638-196c-48db-ad59-f7a047dfb227)

**Next:Nodepools**

![image](https://github.com/user-attachments/assets/6bb07fc1-ff19-4a73-8341-b9c94655f782)

**Next:Networking**

- Public access ip:In browser check my ip

![image](https://github.com/user-attachments/assets/ffbb803d-ec9f-423f-90c9-b91d24ce4d9f)
![image](https://github.com/user-attachments/assets/dbd42219-846e-48f3-b80e-9a3cc8dbc9c9)

**Next:Integrations**

![image](https://github.com/user-attachments/assets/03e9d51a-83d2-4f9a-a202-6cfedce3e308)

**Next:Security**

- Enable keyvault to store secrets

![image](https://github.com/user-attachments/assets/8c1c6bff-50b4-45c6-a65d-9de02e562450)

**Review+create**

### Step 2: Create Azure mysql flexible server.

Add Database details in github secret

![image](https://github.com/user-attachments/assets/0d35c9f6-fe4c-45a9-ba99-f195dce1efa3)

### Step 3 :create Dockerfile.

- Check "ems-ops-phase" in current directory.

- Create Dockerfile for frontend in ems-ops-phase > react-hooks-frontend.

```
# Use the official Node.js image as a base
FROM --platform=linux/arm64 node:14-alpine

# Set the working directory inside the container
WORKDIR /app

# Copy package.json and package-lock.json files to the working directory
COPY package*.json ./

# Install dependencies
RUN npm install

# Copy the rest of the application code to the working directory
COPY . .

# Expose port 3000 for the application
EXPOSE 3000

# Command to run the application
CMD ["npm", "start"]
```
- docker build -t react .

----------------------------------------------------------------------------------------------------------------------------
**ERROR FACED**

![image](https://github.com/user-attachments/assets/f44871ed-7ab5-454d-8596-d0604e1f2cc0)


- Check Node Architecture via kubectl
```
kubectl get nodes -o wide
```
- Then to get the architecture specifically:
```
kubectl get nodes -o jsonpath="{range .items[*]}{@.metadata.name}:{@.status.nodeInfo.architecture}{'\n'}"
```
![image](https://github.com/user-attachments/assets/013754ba-0664-43f4-9ee0-93ab5fbd479d)

- AKS cluster nodes are arm64 architecture.So Dockerfile base image wants to supports arm64.(FROM --platform=linux/arm64 node:14-alpine)
---------------------------------------------------------------------------------------------------------------------------
 - Create dockerfile for backend in ems-ops-phase > springboot-backend
```
# Step 1: Use Maven to build the project
FROM maven:3.8.5-openjdk-17 AS build

WORKDIR /app

# Copy the project files to the container
COPY . .

# Build the application (without running tests)
RUN mvn clean package -DskipTests

# Step 2: Use a minimal Java runtime for the final image
FROM openjdk:17-jdk-slim

WORKDIR /app

# Copy the built JAR file from the Maven stage
COPY --from=build /app/target/springboot-backend-0.0.1-SNAPSHOT.jar /app/springboot-backend.jar

# Expose the application port
EXPOSE 8080

# Run the application
ENTRYPOINT ["java", "-jar", "/app/springboot-backend.jar"]
```
- docker build -t spring .
- docker images

### Step 4:push image to container registry.

[Refer](https://github.com/Ranjitha75388/projects/edit/main/Azure/12%20.%20Container%20app%20.md)

- Add details in github secrets. AZURE_CLIENT_ID , AZURE_TENANT_ID , AZURE_SUBSCRIPTION_ID , ACR_NAME , REGISTRY_USERNAME , REGISTRY_PASSWORD 

- Clone git repo "githubactions".

- cd ranjitha > githubactions > .github > workflows > nano aks.yaml
```
name: Build & Push to AKS

on:
  push:
    branches:
      - main

permissions:
  id-token: write
  contents: read

jobs:
  build-and-push:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout Repository
      uses: actions/checkout@v3

    # Login to Azure
    - name: Login to Azure
      uses: azure/login@v1
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

    # Login to Azure Container Registry (ACR)
    - name: Docker Login to ACR
      uses: docker/login-action@v3
      with:
        registry: ${{ secrets.ACR_NAME }}.azurecr.io
        username: ${{ secrets.REGISTRY_USERNAME }}
        password: ${{ secrets.REGISTRY_PASSWORD }}

    # Add this step *before* the docker/build-push-action
    - name: Set up QEMU
      uses: docker/setup-qemu-action@v3


    # Build and Push Frontend Image for arm64
    - name: Build and Push Frontend
      uses: docker/build-push-action@v5
      with:
        context: ./react-hooks-frontend
        push: true
        tags: ${{ secrets.ACR_NAME }}.azurecr.io/frontend:latest
        platforms: linux/arm64

    # Build and Push Backend Image for arm64 with DB build args
    - name: Build and Push Backend
      uses: docker/build-push-action@v5
      with:
        context: ./springboot-backend
        push: true
        tags: ${{ secrets.ACR_NAME }}.azurecr.io/backend:latest
        platforms: linux/arm64
        build-args: |
          DB_HOST=${{ secrets.DB_HOST }}
          DB_PORT=${{ secrets.DB_PORT }}
          DB_USER=${{ secrets.DB_USER }}
          DB_PASSWORD=${{ secrets.DB_PASSWORD }}
          DB_NAME=${{ secrets.DB_NAME }}

```
- cd githubactions --- gitadd . --- git commit -m "aks added" --- git push origin main

### step 5: Check image in container registry

container registry > Repositories 

![image](https://github.com/user-attachments/assets/f0ea859f-679f-4eab-ab8e-615291c22902)


### Step 6 : Create frontend deployment
```
nano frontend.yaml
```
```
apiVersion: apps/v1
kind: Deployment
metadata:
  name: react-frontend
spec:
  replicas: 1
  selector:
    matchLabels:
      app: react-frontend
  template:
    metadata:
      labels:
        app: react-frontend
    spec:
      containers:
        - name: react-frontend
          image: containerregistrydemo123.azurecr.io/frontend:latest
          imagePullPolicy: Always
          ports:
            - containerPort: 80
---
apiVersion: v1
kind: Service
metadata:
  name: react-service
spec:
  type: LoadBalancer
  selector:
    app: react-frontend
  ports:
    - port: 80
      targetPort: 3000

```
Apply it.
```
kubectl apply -f frontend.yml
```
- Check pods and services
  
![Screenshot from 2025-05-16 20-57-08](https://github.com/user-attachments/assets/1c1969d3-d1dd-45f2-bf07-3e980915fdeb)

#### Check in browser

![Screenshot from 2025-05-16 20-56-33](https://github.com/user-attachments/assets/58f3cafa-9a59-43ca-9acc-f5bc24ec7ccc)


### Step 7 : Create Kubernetes Secret for DB Credentials

```
kubectl create secret generic db-secret \
  --from-literal=username='myuser@mydb' \
  --from-literal=password='yourpassword'
```  
![image](https://github.com/user-attachments/assets/1af6850a-9927-4782-926c-bdf0ce59e005)

### Step 8 : Create backend deployment.
```
nano backend.yml
```
```
apiVersion: apps/v1
kind: Deployment
metadata:
  name: backend
spec:
  replicas: 1
  selector:
    matchLabels:
      app: backend
  template:
    metadata:
      labels:
        app: backend
    spec:
      containers:
        - name: backend
          image: containerregistrydemo123.azurecr.io/backend:latest
          ports:
            - containerPort: 8080
          env:
            - name: DB_HOST
              value: mysql-db-demo.mysql.database.azure.com    # << Azure host
            - name: DB_PORT
              value: "3306"
            - name: DB_NAME
              value: new_flexible_db                              # << Your DB name
            - name: DB_USER
              valueFrom:
                secretKeyRef:
                  name: db-secret
                  key: username
            - name: DB_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: db-secret
                  key: password
---
apiVersion: v1
kind: Service
metadata:
  name: backend-service
spec:
  selector:
    app: backend
  ports:
    - protocol: TCP
      port: 8080
      targetPort: 8080
  type: LoadBalancer  # Optional: only if you want public access
```
Apply it.
```
kubectl apply -f backend.yml
```
### Step 9 : Check pods and services

![image](https://github.com/user-attachments/assets/b5ee57dd-52de-422d-bb17-eb93c4512940)

### Step 10 : Redeploy the frontend.

- Get backend external-ip.

- githubactions >  react-hooks-frontend > src > service > nano Employee.service

![image](https://github.com/user-attachments/assets/ec05e9ba-e5e5-4d36-9d09-74d0ea54a9de)

- Delete old deployment
```
kubectl get deployment
```
![image](https://github.com/user-attachments/assets/3f0f4a38-ff08-4074-a0ab-d1baf1178128)

```
kubectl delete deployment react-frontend
```
- Create new deployment
```
kubectl apply -f frontend.yml
```
- check pods and services.

### Step 11 : check in browser

```
http:// <frontend-external-ip>
```

![image](https://github.com/user-attachments/assets/6fa7b4a3-8f18-4c52-8455-da68aebe3374)
