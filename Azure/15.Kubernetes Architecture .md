# Kubernetes

- Kubernetes (also called K8s) is a tool used to manage and run applications in containers — like Docker — automatically.

- Think of Kubernetes as a manager or traffic controller that takes care of:

    - Starting your app

    - Keeping it running

    - Restarting it if it crashes

     - Scaling it up if traffic increases

     - Spreading it across multiple machines

## Advantages of Kubernetes
1.Auto-Healing
2.Scalability
3.Load Balancing
4.Works Anywhere( laptop, in a private datacenter, or on public clouds like AWS, Azure)
5.Isolation (namespace)


## Kubernetes Architecture Diagram

![image](https://github.com/user-attachments/assets/e451f2e5-689d-4fbb-a558-e8662f57f5e7)

### Nodes

- The main component of the Kubernetes architecture is a resource called as a **Node**.
- A node is one machine in the cluster.

### Cluster
- When these Nodes are connected together, you will get a Kubernetes cluster.
- A cluster is a group of machines (computers or VMs) working together. In Kubernetes, the cluster is where all your apps run.
-  Example, if you connect 3 VMs (Nodes), you will have a Kubernetes cluster with 3 nodes.
-  Every workload that you deploy to the cluster runs on a particular node.
-  This node is either auto-selected by one of the Kubernetes components called the **kube-scheduler**, or you can manually define some rules on which node the workload should run. 

### Two Types of Nodes

#### 1. Control Plane Node

  - The control plane is the brain of Kubernetes.
  - It makes decisions about the cluster, like where to run your apps, and keeps everything in order.

#### 2. Worker Node

   - These are the "employees" or "workers".

   - The worker node (or minion) as it is also known, is were the containers are hosted.

   - They actually run your apps.

   - They listen to the Control Plane for instructions.
   - Worker nodes can be scaled up or down depending on how much traffic or load your application has.

## Control Plane Components 

#### 1.API Server

- The front door of the Kubernetes cluster.

- It receives all requests (from users or other parts of Kubernetes(via kubectl or other tools))

- It checks who’s making the request

- It makes sure that the request is safe and allowed (authentication & authorization)

- Then it forwards the request to the correct part of the cluster

#### 2.ETCD

- IT's is like the brain or memory of your Kubernetes cluster.

- It stores all the important information about your cluster, like: What’s running?, What’s been created or deleted?, What’s the current status of different parts of the system?

- Only the API Server is allowed to talk directly to ETCD.If any other part of Kubernetes wants to read or update information in etcd, it must go through the API Server.

-  High Availability ETCD cluster (more than one etcd instance)

- There are two main ways to set up etcd in a cluster:

   1. Stacked etcd

       - etcd runs inside the Control Plane

       - This is the most common setup

       -  Easy to manage for most clusters

   2. External etcd

       - etcd runs outside the Kubernetes cluster (like on a different machine)

        - Kubernetes talks to it by using its IP address or URL, which is set in the API Server’s settings
 
#### 3. Scheduler

- Pod

  - A pod is the smallest unit in Kubernetes. It runs one or more containers (like Docker containers).

    -  Every app runs inside a pod.

     - Pods live on nodes.

- Who Chooses the Node?

   That job is done by a component called the **kube-scheduler**.

   - It looks at all the available nodes

   - Checks which one is the best fit (based on memory, CPU, etc.)

   - Then places your pod on that node

   - You can either:

     -  kube-scheduler can decide automatically, or

     - Set rules to guide where your pod should go (like picking a node with certain labels)

#### 4.Controller Manager

- controllers are like watchdogs that keep an eye on the cluster. They check if things are running the way they should, and if not, they take action to fix it.

 - There are different controllers for different jobs, like:

    - Deployment Controller – Makes sure the right number of pods are always running.

    - Replication Controller – Keeps a specific number of copies (replicas) of a pod running.

     - Endpoint Controller – Connects services to the right pods.

    - Namespace Controller – Manages namespaces (groupings of resources).

    - Service Account Controller – Manages service accounts for pods.

 - All these controllers are part of a bigger component called the **Controller Manager**, which runs all the controllers in one place.

 - Also can create our own custom controller.

#### 5.Cloud Controller Manager
- Cloud Controller Manager (CCM) is like a bridge between Kubernetes and cloud provider to create or remove resources (like VMs or networking stuff)

- Example:If cluster has 10 nodes, and they’re all full. You want to run more apps, but there’s no space. The CCM can ask your cloud provider to create a new VM (node) and add it to the cluster — automatically.

## Worker Nodes Components

#### 1.Kubelet

-  The Kubelet is an agent that runs on every node in a Kubernetes cluster (as a system service, not inside a pod).

- It listens for instructions from the Control Plane (specifically the API Server) to ensure that the correct pods are running and healthy on its node.

- It is responsible for maintaining the desired state of the pods and ensuring that they are running according to the specifications provided by the Kubernetes API.

- The Kubelet also checks the health of the pods and containers, restarting them if they fail, and reporting the status back to the Control Plane.

- Without the Kubelet, no pods or containers can be created or managed on that node.

#### 2.Kube Proxy

- Kube-Proxy is like the network traffic manager for Kubernetes cluster.
- It makes sure that all parts of the cluster can talk to each other.

- It routes traffic between services and pods.

- It supports common network types like TCP, UDP, and SCTP.
- Kube-Proxy is installed on every node in the cluster.
- It keeps a routing table that helps it know where to send traffic inside the cluster.

#### 3.Container Runtime

- Kubernetes is a tool that runs and manages containers, but it doesn’t create containers by itself. It uses a special software called a container runtime to do that.

- The Kubelet tells the node: "I need this pod with these containers."

- The container runtime is what actually creates and **runs those containers inside the pod**.

## Namespace

- Namespaces help you organize your apps into separate environments inside the same cluster.

  - Example: You can have dev, test, and prod environments all in one cluster using namespaces.


## Deployment

- A deployment is a Kubernetes resource that manages pods. It keeps your app running and handles updates.

   - Example: "Hey Kubernetes, I want 3 copies of this app running."
    The deployment will make sure 3 pods are running.

## Service

- A service gives your pod(s) a fixed way to be accessed, like a phone number.

- Even if pods change or restart, the service stays the same.

- It also balances traffic between multiple pods.

## kubectl 

- kubectl is the command-line tool you use to interact with your Kubernetes cluster.

- You use it to create, manage, and inspect resources in the cluster. It's like the remote control for your Kubernetes cluster.



## Install Kubernetes locally using minicube

### Step-by-Step Setup:

#### 1.Install kubectl on Linux

Step 1: Download the latest release
```
curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
```
Step 2: Make the file executable
```
chmod +x kubectl
```
Step 3: Move the binary to your path
```
sudo mv kubectl /usr/local/bin/
```
Step 4: Verify installation
```
kubectl version --client
```
![image](https://github.com/user-attachments/assets/4f88d611-910d-4ff9-b16d-1eb4a2ca44f8)

#### 2.Install Minikube

```
curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
sudo install minikube-linux-amd64 /usr/local/bin/minikube
```
#### 3.Start Minikube:
```
minikube start
```
![image](https://github.com/user-attachments/assets/76452a7f-ac63-43b6-a775-58313695d42a)

#### 4.Check if your cluster is running:
```
kubectl get nodes
```
![image](https://github.com/user-attachments/assets/62e39ead-a394-4a88-aa0d-2d233f774b56)


- Access to AKS
```
az aks get-credentials --resource-group <resourse-group-name> --name <cluster name>
```
- to get current public-ip
  ```
  curl -s https://ifconfig.me
  ```





