# 1. Build and Push a Docker Image to Azure Container Registry (ACR) from GitHub Actions

- A **Container Registry** is a storage and management service for Docker images. It allows developers to store, manage, and distribute container images securely.
- GitHub Actions builds a Docker image and pushes it to the registry.
- Other services (Azure Container Apps, Kubernetes, etc.) can pull images from the registry.

## Step 1: Create an Azure Container Registry (ACR)

   - Sign in to Azure Portal
   - Search for Container Registry and click Create.
   
![image](https://github.com/user-attachments/assets/b0d17d23-c827-4745-b85a-8df4d1d7d386)
-  Click Review + Create and then Create.

  ##  Step 2: Get ACR Login Credentials

  -  Go to your Container Registry in Azure Portal.
  -  Under Settings, click Access Keys.
  -  Enable Admin User.
  -  Copy the following details for GitHub Actions:

     - Login Server:containeregistry.azurecr.io

      -   Username   : containeregistry                        :

     - Password   :k/HMPW5Sqdc/yc7L3ZSPsetpJmiWkjchhff2VDr6oa+ACRBoRFQa
      
     ![image](https://github.com/user-attachments/assets/b11674e4-03aa-4315-acaf-12c79429ee3b)


## Step 3: Create Service principal ID 

#### What is a Service Principal ID?

- A Service Principal is an Azure identity that allows applications (like GitHub Actions) to authenticate and interact with Azure without using a user account.

- The Service Principal Client ID (AZURE_CLIENT_ID) is an application (client) ID that uniquely identifies the Service Principal in Azure.

## How to Create a Service Principal in Azure Portal

### Step 1: Go to Azure Active Directory

- Search App registrations.

- Click + New registration.

### Step 2: Register a New Application

![image](https://github.com/user-attachments/assets/eb615018-c284-4bd7-a50b-4c7c7a2f3854)


- Click Register.

### Step 3: Get the Required IDs

 After registering, you will see the Application Overview page. Copy these values:

-  Application (client) ID → This is your AZURE_CLIENT_ID.

-  Directory (tenant) ID → This is your AZURE_TENANT_ID.

  ![image](https://github.com/user-attachments/assets/116936d8-1d2a-4b92-bfaa-ba91d3ae13b3)


### Step 4: Create a Client Secret (if needed)

-    In the left menu, click Certificates & secrets.

-   Click + New client secret.

-   Enter a description (e.g., GitHub Secret).

-  Set the expiration period (e.g., 1 year).

-  Click Add.

- Copy the Value (not the Secret ID) → This is your **AZURE_CLIENT_SECRET**:XMp8Q~UcNLS5QKX_MrRYkF4T87uRqNpYE29C6c9d
  
  [**(no need)** secret-id:bdc05a07-9926-4ee3-856d-f8064d5e8976 ]

#### Important: The client secret will be shown only once. Copy it immediately.   


### Step 5: Assign Permissions to the Service Principal

- Go to Subscriptions in the Azure Portal.

- Select your Azure Subscription.

- Click Access control (IAM).

- Click + Add role assignment.

-  Choose Contributor role.

- In the Members tab:
     
     - Click + Select members.
     
     -  Search for the Application Name (e.g:application-service-principal-ID).

     -  Select it and click Next.
 
 -   Click Review + Assign.

## Step 4: Configure Federated Credentials in Azure (another method insteed of creating service principal ID)

- Federated Credentials allow GitHub Actions to authenticate without storing passwords or secrets.

- This method uses OpenID Connect (OIDC) to provide secure authentication.

- Search App Registrations

-  Select your Service Principal (application-service-principal-ID)

 - Go to "Certificates & Secrets" → "Federated Credentials"

- Click "Add a credential"

- Select **Federated credential scenario**  : "GitHub Actions deploying Azure resources"

-  Set the following values:

      -  Organization: Your GitHub Organization (your-org-name)

     - Repository: Your GitHub Repository (your-repo-name)

    - Entity Type: Environment
    
    - Name: GitHub-Actions
    
    - Audience: api://AzureADTokenExchange

- Click Create

![image](https://github.com/user-attachments/assets/f3da2147-142f-4b7b-9da9-fbd188bceaf7)


## step 5 : Configure GitHub Secrets

-  Go to your GitHub repository.

-  Navigate to Settings → Secrets and variables → Actions.

-   Add the following secrets:

![image](https://github.com/user-attachments/assets/33743117-0c38-4628-81c2-cd96aafb0fac)


-  AZURE_CLIENT_ID → acb9e866-d3f7-4c17-886c-f06579005b9e

- AZURE_TENANT_ID → 62d68a08-d1c9-46f7-9a34-fb1738cf4c7d

- AZURE_SUBSCRIPTION_ID → 07ee8e08-7d5b-420b-9bec-bc242df1c043

- ACR_NAME → containeregistry

-  REGISTRY_USERNAME → containeregistry

-  REGISTRY_PASSWORD → k/HMPW5Sqdc/yc7L3ZSPsetpJmiWkjchhff2VDr6oa+ACRBoRFQa

## Step 6: Create a Dockerfile for frontend and backend

- ####  In terminal clone your gitrepo(github-actions) --> cd react-hooks-frontend -->nano  Dockerfile

```
# Use the official Node.js image as a base
FROM node:14

# Set the working directory inside the container
WORKDIR /app

# Copy package.json and package-lock.json files to the working directory
COPY package*.json ./

# Install dependencies
RUN npm install

# Copy the rest of the application code to the working directory
COPY . .

# Expose port 3000 for the application
EXPOSE 3000

# Command to run the application
CMD ["npm", "start"]
```

- Create a docker image to run in container to verify the dockerfile beforre running workflow file in github Actions.

- docker build -t my-react-app .

- sudo docker run -d -it --name con1 -p 3000:3000 react

- check in browser localhost:3000

- ### Next for backend: github-actions --> cd sprinboot-backend --> nano Dockerfile

```
# Step 1: Use Maven to build the project
FROM maven:3.8.5-openjdk-17 AS build

WORKDIR /app

# Copy the project files to the container
COPY . .

# Build the application (without running tests)
RUN mvn clean package -DskipTests

# Step 2: Use a minimal Java runtime for the final image
FROM openjdk:17-jdk-slim

WORKDIR /app

# Copy the built JAR file from the Maven stage
COPY --from=build /app/target/springboot-backend-0.0.1-SNAPSHOT.jar /app/springboot-backend.jar

# Expose the application port
EXPOSE 8080

# Run the application
ENTRYPOINT ["java", "-jar", "/app/springboot-backend.jar"]


```
- Create docker image to run the container.
- sudo docker build -t springboot .
- sudo docker run -d -it --name con1 -p 8080:8080 spring
- git add .
- git commit -m "files added"
- git push origin main 

### Step 7 : create mysql flexible server

![image](https://github.com/user-attachments/assets/e98ce91d-e3ad-4156-aa20-c143d65df868)

- Change the database details in application properties
```
spring.datasource.url=jdbc:mysql://mysql-flexible-server-demo.mysql.database.azure.com:3306/new_flexible_db?useSSL=true&requireSSL=true&verifyServerCertificate=true
spring.datasource.username=ranjitha@mysql-flexible-server-demo
spring.datasource.password=tharshik@123
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQLDialect
spring.jpa.hibernate.ddl-auto=update
```

- Add Database details in github secret

![image](https://github.com/user-attachments/assets/0d35c9f6-fe4c-45a9-ba99-f195dce1efa3)


### Step 8 :Push images to Azure Container Registry (ACR)

 In terminal github-actions(git repo name) ---> cd .github ---> cd workflows ---> nano build and push image to ACR

```
name: Build & Push to ACR

on:
  push:
    branches:
      - main

permissions:
  id-token: write
  contents: read

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout Repository
      uses: actions/checkout@v3

    # Login to Azure using OIDC authentication
    - name: Login to Azure
      uses: azure/login@v1
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

    # Login to Azure Container Registry (ACR)
    - name: Login to Azure Container Registry (ACR)
      run: |
        echo "${{ secrets.REGISTRY_PASSWORD }}" | docker login ${{ secrets.ACR_NAME }}.azurecr.io -u ${{ secrets.REGISTRY_USERNAME }} --password-stdin
    # Build and Push Frontend Image
    - name: Build and Push Frontend
      run: |
        docker build -t ${{ secrets.ACR_NAME }}.azurecr.io/frontend:latest ./react-hooks-frontend
        docker push ${{ secrets.ACR_NAME }}.azurecr.io/frontend:latest
    # Build and Push Backend Image with Database Secrets
    - name: Build and Push Backend
      run: |
        docker build \
          --build-arg DB_HOST=${{ secrets.DB_HOST }} \
          --build-arg DB_PORT=${{ secrets.DB_PORT }} \
          --build-arg DB_USER=${{ secrets.DB_USER }} \
          --build-arg DB_PASSWORD=${{ secrets.DB_PASSWORD }} \
          --build-arg DB_NAME=${{ secrets.DB_NAME }} \
          -t ${{ secrets.ACR_NAME }}.azurecr.io/backend:latest ./springboot-backend
        docker push ${{ secrets.ACR_NAME }}.azurecr.io/backend:latest
```
- git add .
- git commit -m "workflow added"
- git push origin main

### Step 9 : Check images added in ACR

- Go to Azure portal
- Go to container registries.
- click container registries that you have created(containeregistry).
- In lefft side menu bar under services,click repositories 

![image](https://github.com/user-attachments/assets/da3f83c0-fd32-4a96-9658-a49c76f20456)

# 2. Manually Deploy the images to Azure Container Apps and ensure the application is working.

- A Container App is a fully managed service in Azure that allows you to run containerized applications without managing Kubernetes or virtual machines. It is part of Azure Container Apps (ACA).
- The container pulls the images from ACR and runs it.
- The services are accessible via a public URL (if --ingress external is used).
- Environment variables (DB settings) are available inside the container.

### Step 1: Create an Azure Frontend Container App

   - Go to Azure Portal.

   - Search for Container Apps and click Create.
   - **Environment**: Click Create new and provide a name.(only one container app environment can be used for free subscription.so here created frontend environment can be use for backend container also.)

   
![image](https://github.com/user-attachments/assets/e5f8fc88-0167-42ee-8cb0-fac1374a6a17)
     
**NEXT:Container**

![image](https://github.com/user-attachments/assets/33a62e74-6dec-42d7-be9d-9607d849ae6c)

**NEXT:Ingress**

- Enable ingress

![image](https://github.com/user-attachments/assets/6001fdc7-43df-4b0a-a9de-1855ba83720a)


- Click Next: **Review + Create** and then **Create**.

### Get the Application URL

- Copy the application URL in overview 

![image](https://github.com/user-attachments/assets/e78383be-6d29-4d0a-a947-aa97e59d0343)


- Run the URL in chrome

![Screenshot from 2025-03-08 22-04-24](https://github.com/user-attachments/assets/b58895c3-de92-4f12-85ba-433e3d14b3f4)

### Step 2:Create Backend container

![image](https://github.com/user-attachments/assets/834cac9e-e5ad-46f6-b734-68e9098aff13)

**NEXT:CONTAINER**

![image](https://github.com/user-attachments/assets/d45de3c2-8c73-43bd-8a51-f41ac0e1ab05)

**NEXT:INGRESS**

![image](https://github.com/user-attachments/assets/a122d9ca-ba60-4a9c-9484-b565efedcc4b)

**REVIEW+CREATE**

- Copy the Application URL and try in browser

- URL:https://backend-container.mangodune-64346aaf.centralindia.azurecontainerapps.io **/api/v1/employees**
  
![image](https://github.com/user-attachments/assets/896c11f4-329f-41bc-bcc3-43f02d071361)

### To work submit button

- Update in reacthooks-frontend ---> cd src/service/employee.service.js (backend URL)

![image](https://github.com/user-attachments/assets/5bbaf8b6-d15c-46e9-86df-f0c3dcfc3178)

- Now check in browser with frontend URL

![Screenshot from 2025-03-07 16-56-38](https://github.com/user-attachments/assets/e3c57d1b-8560-4fba-8828-404ff8ab966f)

# 3. Automate Deployment by setting up GitHub Actions to build and deploy the image to Azure Container Apps. 


### Step 1 : Add github secrets

  ![image](https://github.com/user-attachments/assets/1d1febdc-cef2-4547-94e7-c89733f13d7b)

- CONTAINERAPPS_ENVIRONMENT   : managedEnvironment-rgranjitha-823e

- CONTAINER_APP_NAME_AUTO     : frontend-auto

- RESOURCE_GROUP              : rg-ranjitha

### Step 2 : Workflow file for automatic deployment frontend container app

- cd gitrepo ---> cd reacthooks-frontend ---> cd Dockerfile
- cd gitrepo ---> cd .github ---> cd workflows ---> nano build and push frontend to container app
  
```
name: Deploy Frontend to Azure Container Apps

on:
  push:
    branches:
      - main
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

jobs:
  build-and-deploy-frontend:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      - name: Log in to Azure
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Log in to Azure Container Registry (ACR)
        run: |
          az acr login --name ${{ secrets.ACR_NAME }}

      - name: Build and Push Docker Image (Frontend)
        run: |
          cd react-hooks-frontend
          docker build -t ${{ secrets.ACR_NAME }}.azurecr.io/my-frontend:latest .
          docker push ${{ secrets.ACR_NAME }}.azurecr.io/my-frontend:latest

      - name: Deploy Frontend to Azure Container Apps
        run: |
          set -e  # Stop script if any command fails

          # Deploy or update the container app
          az containerapp up \
            --name "${{ secrets.CONTAINER_APP_NAME_AUTO }}" \
            --resource-group "${{ secrets.RESOURCE_GROUP }}" \
            --environment "${{ secrets.CONTAINERAPPS_ENVIRONMENT }}" \
            --image "${{ secrets.ACR_NAME }}.azurecr.io/my-frontend:latest" \
            --ingress external \
            --target-port 3000 \
```

### Step 3 : Check image added in container registries ---> repository

![image](https://github.com/user-attachments/assets/2f70011e-4e84-4a92-be2a-47c8b492acf1)

### Step 4 : check frontend container added in container app

![image](https://github.com/user-attachments/assets/aaf4180a-24e7-4f77-a835-d5be8ebd41d6)

### Step 5 : check with  frontend URL

![image](https://github.com/user-attachments/assets/a1681ba6-f79c-46b3-80e0-e69bd02da72b)

### Step 6 : Create backend container app   

- In github secret add 
**CONTAINER_APP_NAME_AUTO_BACKEND**   : backend-auto

- gitrepo ---> cd .github ---> cd workflows ---> nano build and push backend to container app

```
name: Deploy backend to Azure Container Apps

on:
  push:
    branches:
      - main
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

jobs:
  build-and-deploy-backend:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      - name: Log in to Azure
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Log in to Azure Container Registry (ACR)
        run: |
          az acr login --name ${{ secrets.ACR_NAME }}

      - name: Build and Push Docker Image (Backend)
        run: |
          cd springboot-backend
          docker build -t ${{ secrets.ACR_NAME }}.azurecr.io/my-backend:latest .
          docker push ${{ secrets.ACR_NAME }}.azurecr.io/my-backend:latest

      - name: Deploy Backend to Azure Container Apps
        run: |
          az containerapp up \
            --name "${{ secrets.CONTAINER_APP_NAME_AUTO_BACKEND }}" \
            --resource-group "${{ secrets.RESOURCE_GROUP }}" \
            --environment "${{ secrets.CONTAINERAPPS_ENVIRONMENT }}" \
            --image "${{ secrets.ACR_NAME }}.azurecr.io/my-backend:latest" \
            --ingress external \
            --target-port 8080 \
            --registry-server "${{ secrets.ACR_NAME }}.azurecr.io" \
            --registry-username "${{ secrets.REGISTRY_USERNAME }}" \
            --registry-password "${{ secrets.REGISTRY_PASSWORD }}" \
            --env-vars \
              SPRING_DATASOURCE_URL="jdbc:mysql://${{ secrets.DB_HOST }}:${{ secrets.DB_PORT }}/${{ secrets.DB_NAME }}" \
              SPRING_DATASOURCE_USERNAME="${{ secrets.DB_USERNAME }}" \
              SPRING_DATASOURCE_PASSWORD="${{ secrets.DB_PASSWORD }}" \
              SPRING_JPA_PROPERTIES_HIBERNATE_DIALECT="org.hibernate.dialect.MySQLDialect" \
              SPRING_JPA_HIBERNATE_DDL_AUTO="update"


```
### Step 7 : Check in container registries,image had added

![image](https://github.com/user-attachments/assets/2e0a9ef0-9938-4168-9168-c7a6d2fa2f19)

### Step 8 : Check container app to backend container added

![image](https://github.com/user-attachments/assets/de8780b1-646f-460a-817f-a3c92606913f)

### Step 9 : Check in browser with backend-auto URL

![image](https://github.com/user-attachments/assets/737aec3d-ac16-4097-bd18-3629170ffb8d)

### Step 10 : To work submit button

- In Reacthooks-frontend ---> cd src/service/employee.service.js
- Replace with backend-auto container URL
- Check in browser
![image](https://github.com/user-attachments/assets/89087ed4-e375-4b13-91e0-13a69cfce83c)
