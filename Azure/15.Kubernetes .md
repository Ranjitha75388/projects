# Kubernetes 

##  What is Kubernetes?

Kubernetes is an open-source container orchestration platform tool that helps to run, manage, and scale containerized apps automatically.

### Key Features:

-    Auto-Scaling: Adds or removes app instances based on traffic.

-   Load Balancing: Shares traffic across app copies.

-  Rolling Updates: Updates apps without downtime.

-   Self-Healing: Restarts crashed apps automatically.

-   Service Discovery: Makes apps find and talk to each other easily.


## 1. Kubernetes Architecture and Main Components




##  Kubernetes Cluster Overview

A **Kubernetes cluster** is a group of computers that work together to run your containerized applications. These computers are divided into two main parts:

### 1. Control Plane (The Brain)

- This is the "brain" of the cluster — it manages the overall cluster.
- Typically, for **high availability**, a production cluster should have **at least 3 Control Plane nodes**, so if one fails, the others can continue managing the cluster.

### 2. Worker Nodes (The Workers)

- Actual computers that run the apps
- They get instructions from the Control Plane
- A cluster can have **1 or many worker nodes** based on the load


##  Control Plane Components

###  API Server

- Entry gate for all commands (like creating pods)
- Accepts commands from CLI (`kubectl`)
- Verifies and sends them to other components
- The only component that directly communicates with users

###  Scheduler

- Chooses the best worker node for new applications (Pods)
- Based on CPU, RAM, and availability
- Decides placement of new Pods

###  Controller Manager

- Watches the cluster and ensures the desired state is met.
- If a pod crashes, it recreates it
- Manages different controllers:
  - Node controller (checks if nodes are healthy)
  - Replication controller (manages replica pods)
  - Endpoints controller (joins services & pods)

###  etcd (Cluster Database)

- A simple key-value store
- Stores all the cluster information (like configurations data, pod status,secrets, and cluster state).

## Worker Node Components 

### Node

- A machine in the cluster
- Runs apps (pods) given by the Control Plane

### Pod

- A wrapper around one or more containers placed in nodes.


### Container Runtime

- Software responsible for running containers (e.g., Docker, containerd).
- Pulls container images and runs them

### kubelet

- Agent that runs on every worker node.
- Talks to Control Plane
- Tells the node what to do (start pod, stop pod)
- Ensures containers described in PodSpec are running

### kube-proxy

- Handles network rules on each node.

- Manages pod-to-pod and pod-to-service communication.

## Summary Table

| Component          | Role                                |
| ------------------ | ----------------------------------- |
| Cluster            | Group of machines running apps      |
| Node               | A single computer in the cluster    |
| Pod                | The smallest unit (runs containers) |
| Container          | The actual app                      |
| Control Plane      | The manager of everything           |
| API Server         | Entry point for commands            |
| Scheduler          | Picks best node for a pod           |
| Controller Manager | Maintains desired state             |
| etcd               | Stores current state                |
| Kubelet            | Runs on each node                   |
| Kube Proxy         | Directs traffic inside cluster      |


## 2. Ways to Set Up a Kubernetes Cluster

### 1.Kubernetes Playground

-  A free, browser-based Kubernetes cluster for practice. No install needed.
- **Pros:**
   - No need to install anything

  - Works on any device (even phones/tablets)

  - Great for learning and practice

  - Completely free
- **Cons:**

    - Temporary (resets after session)

    - No customization or scaling

    - Not for real apps

- **How to Use:**

    - Go to: https://killercoda.com/playgrounds

    - Click on “Kubernetes Playground”

    - Click “Start Playground”

    - Use the terminal to try:

    ```
    kubectl get nodes
    kubectl create deployment nginx --image=nginx
    kubectl get pods
    ```
### 2.Manual Setup (Kubernetes The Hard Way)

 -  Install and configure each Kubernetes component manually (API Server, Controller Manager, etc.)
 
 - **pros**

   - You learn exactly how Kubernetes works

   - Full control over every part of the setup

- **cons**

    - Very hard and time-consuming

    - Easy to make mistakes

    - Not ideal for real production use

 - **Steps:**

    - Create VMs or cloud machines (1 master + workers)

    - Install etcd (Kubernetes database)

    - Install Kubernetes parts: API server, scheduler, controller

    - Install kubelet and kube-proxy on workers

    - Set up TLS certificates and network plugin (like Calico)

    - Connect everything together manually


 [](https://github.com/kelseyhightower/kubernetes-the-hard-way)
 
### 3.Minikube – Local Kubernetes on Your Laptop

- A tool to run Kubernetes on your own laptop — great for learning and testing.

- **pros**

    - Easy to start: Just a few commands and it’s running.

    - Great for developers: Perfect for learning and local testing.

    - Free & open-source: No cost, no limits.
- **Cons** 

    - Not for real use: Just for learning and development, not production.

    - Uses your system resources: Needs decent CPU and RAM.

- **Step by step to Install Minikube**

  #### 1.Install kubectl on Linux

  Step 1: Download the latest release
  ```
  curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
  ```
  Step 2: Make the file executable
  ```
  chmod +x kubectl
  ```
  Step 3: Move the binary to your path
  ```
  sudo mv kubectl /usr/local/bin/
  ```
  Step 4: Verify installation
  ```
  kubectl version --client
  ```
  ![image](https://github.com/user-attachments/assets/4f88d611-910d-4ff9-b16d-1eb4a2ca44f8)

  #### 2.Install Minikube

  ```
  curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
  sudo install minikube-linux-amd64 /usr/local/bin/minikube
  ```
  #### 3.Start Minikube:
  ```
  minikube start
  ```
  ![image](https://github.com/user-attachments/assets/76452a7f-ac63-43b6-a775-58313695d42a)

  #### 4.Check if your cluster is running:
  ```
  kubectl get nodes
  ```
  ![image](https://github.com/user-attachments/assets/62e39ead-a394-4a88-aa0d-2d233f774b56)

### 4.Using Kubeadm (Semi-Automated Setup):

-  Kubeadm is a tool that helps you install a real Kubernetes cluster.
  
- It sets up the control plane (master) and lets you add worker nodes.

- **Pros**

    - **Full Control**: You decide what to install and how.

    - **Real Kubernetes**: It sets up the actual, full Kubernetes system used in big companies.

    - **Supports Everything**: You can add networking, storage, and other features you need.

    -  **Multi-node Setup:** You can connect multiple machines to create a larger, stronger cluster.

    - **Secure**: Automatically sets up encryption for secure communication.

    - **Good for Learning**: Helps you understand how Kubernetes really works behind the scenes.

- **Cons**

    - **Manual Setup:** You have to install and configure everything yourself (no easy wizard).

    - **Needs More Machines**: Best when you use 2+ machines, not just 1 (even if using VMs).

    - **No Built-in Dashboard**: You have to install a UI (like the Kubernetes Dashboard) separately if you want it.

    - **More Work**: You’ll need to handle updates, backups, and other maintenance tasks yourself.

- **Steps to Install with Kubeadm**
  
  **Step 1: Prepare your nodes (VMs or servers)**

    Minimum: 1 master + 1 worker

   **Step 2: Install kubeadm, kubelet, kubectl**
    ```
    sudo apt-get update
    sudo apt-get install -y apt-transport-https ca-certificates curl
    curl -fsSLo /usr/share/keyrings/kubernetes-archive-keyring.gpg https://packages.cloud.google.com/apt/doc/apt-key.gpg
    echo "deb [signed-by=/usr/share/keyrings/kubernetes-archive-keyring.gpg] https://apt.kubernetes.io/ kubernetes-xenial main" | sudo tee /etc/apt/sources.list.d/kubernetes.list
    sudo apt-get update
    sudo apt-get install -y kubelet kubeadm kubectl
    sudo apt-mark hold kubelet kubeadm kubectl
    ```
  **Step 3: Install container runtime (Docker or containerd)**

    (Example below uses Docker)
    ```
    sudo apt-get remove -y docker docker.io containerd runc
    sudo apt-get install -y ca-certificates curl gnupg lsb-release
    sudo mkdir -p /etc/apt/keyrings
    curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
    echo \
    "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
    $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
    sudo apt-get update
    sudo apt-get install -y docker-ce docker-ce-cli containerd.io
    ```
  **Step 4: Initialize Master Node**
    ```
    sudo kubeadm init
    ```
  **Step 5: Configure kubectl access**
    ```
    mkdir -p $HOME/.kube
    sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
    sudo chown $(id -u):$(id -g) $HOME/.kube/config
    ```
  **Step 6: Install CNI plugin (networking)**

    Example using Weave:
    ```
    kubectl apply -f "https://cloud.weave.works/k8s/net?k8s-version=$(kubectl version | base64 | tr -d '\n')"
    ```
  **Step 7: Join worker nodes**

    Run the **kubeadm join** command shown in Step 4 on your worker nodes.

### 3.Using Managed Kubernetes Services (Cloud-Managed Kubernetes):

 -   Cloud providers like AWS (EKS), Azure (AKS), and Google Cloud (GKE) offer **fully-managed Kubernetes** services.

 - **Pros**

  1.Production-Ready: Suitable for real company projects; used by many businesses.

  2.Very Easy to Start: You can create a Kubernetes cluster in seconds using a few clicks or simple commands.

  3.Cloud Manages Control Plane:No need to install or maintain Kubernetes internals (like API server, etcd) — Cloud does it for you.

  4.Scaling & Monitoring Built-In:You can easily scale up/down and monitor your cluster with cloud tools.

  5.Security & Updates Handled:Cloud keeps your cluster secure with automatic updates, SSL certificates, and patches.

  6.Focus on Apps, Not Infrastructure: You manage applications, not servers or networking details.

- **Cons**

  1. Need a Cloud Account: You must set up and manage an account with AWS, Azure, or Google Cloud.

  2. Less Control: You can't deeply modify core Kubernetes components easily.

  3.Not Fully Maintainable:If you create clusters manually (via console or basic CLI), it's hard to track and re-create exactly unless you use automation tools (like Terraform).

  4.Can Be Expensive:Even unused clusters can cost you money (example: AWS EKS ~$73/month),and you must remember to shut down when not using.

  5.Vendor Lock-In: Moving clusters between cloud providers is complicated.
#### - Key Features of AKS

1. Fully Managed Control Plane: Cloud provider handles upgrades, patches, backups, and high availability.

2.Very Easy Setup: Create a Kubernetes cluster in just a few clicks or simple CLI commands.

3.Built-in Security: Supports Identity integrations (like Azure AD), RBAC (Role-Based Access Control), and secrets management.

4.Auto Scaling : Cluster can automatically scale pods or nodes based on CPU, memory, or custom metrics.

5.Monitoring & Logs Available : Use built-in tools like Azure Monitor, CloudWatch, or Stackdriver to track health and performance.

6.CI/CD Integration : Easily connect to GitHub, Azure DevOps, Jenkins, and other pipelines for automatic deployments.

7.Simple Rolling Updates : Update Kubernetes versions or apps smoothly without downtime.

8.Pay Only for Worker Nodes: You only pay for the VMs (nodes); the control plane is free (like in AKS).

9.High Availability and Disaster Recovery : Cloud providers ensure the control plane is highly available across multiple zones.

10.Expert Cloud Support : Access to professional support from Microsoft, AWS, or Google.

- **Cons**

 1. Less Control: You cannot deeply customize the Kubernetes internal settings (like etcd tuning, kube-apiserver flags).

 2. Cloud Account Required : Need to create and maintain a cloud account with Azure, AWS, or Google Cloud.

3. Costs Can Be High: Running clusters 24/7 can get expensive if not properly managed.
    (Example: AWS EKS ~$73/month for control plane, though AKS is free.)

4. Vendor Lock-In Risk : Migrating clusters between clouds (AWS to Azure, etc.) can be difficult.

5.Not Fully Declarative Out of the Box: Manual setups via console or CLI are not easily repeatable unless you use Infrastructure as Code tools (Terraform, Pulumi).



### Basic Steps to Use AKS

1.Login to Azure:
```
  az login
```
2.Create a Resource Group:
```
  az group create --name myResourceGroup --location eastus
```
3.Create AKS Cluster:
```
  az aks create --resource-group myResourceGroup --name myAKSCluster --node-count 2 --enable-addons monitoring --generate-ssh-keys
```
4.Connect to AKS:
```
  az aks get-credentials --resource-group myResourceGroup --name myAKSCluster
```
5.Check Cluster:
```
  kubectl get nodes
```

## Common Kubectl Commands

| Action         | Command                       |
| -------------- | ----------------------------- |
| List Pods      | `kubectl get pods`            |
| List Nodes     | `kubectl get nodes`           |
| List Services  | `kubectl get services`        |
| Describe a Pod | `kubectl describe pod <name>` |
| Delete a Pod   | `kubectl delete pod <name>`   |
| Get All Resources | `kubectl get all`         |


## 4. Categorized Kubernetes Concepts

### 1. Networking in Kubernetes

Networking handles how containers and services talk to each other inside and outside the cluster.
### - Pods

   - Basic unit of deployment.

   - Each pod gets its own IP address.

   - All containers inside a pod share the same network namespace.

### - Services

    Provides a stable way to access pods, even if pod IPs change.

    Types:

        ClusterIP: Default, internal access only.

        NodePort: Exposes the service on a static port on each node.

        LoadBalancer: Exposes service externally via cloud provider load balancer.

        ExternalName: Maps a service to an external DNS name.

### - Load Balancing

    Distributes incoming traffic across multiple pods to ensure high availability and performance.

### - Network Policies

    Define rules to control traffic between pods and namespaces.

    Example: Only allow frontend pod to talk to backend.

### - CNI (Container Network Interface) Plugins

    Handles networking between pods.

    Examples: Calico, Flannel, Weave Net.

## 2. Security in Kubernetes

Security ensures your cluster and applications are protected from unauthorized access or misuse.
### - API Access & Authentication

    Only authorized users should access Kubernetes API.

    Can use service accounts, user tokens, or cloud IAM systems.

 ### - RBAC (Role-Based Access Control)

    Controls who can do what on which Kubernetes resources.

 ### - TLS Encryption

    Ensures communication between control plane components is secure and encrypted.

### - Secrets

    Securely stores sensitive information like passwords, tokens, or keys.

    Can be injected into pods.

### - Pod Security Standards (PSS) (Replacement of PodSecurityPolicy)

    Enforce pod-level security like:

        Prevent running as root.

        Prevent privileged escalation.

### - Namespaces

    Logical partitions in a cluster.

    Useful for multi-team environments or isolating environments (e.g., dev/test/prod).

🧠 The 4 Cs of Kubernetes Security

    Cloud (infrastructure layer)

    Cluster (Kubernetes setup)

    Container (container runtime and image)

    Code (application code security)

##  3. Scheduling in Kubernetes

Scheduling is all about where and how pods are placed on nodes.
### - Kube-scheduler

    Component that decides which node a pod should run on, based on availability, policies, and requirements.

### - Taints & Tolerations

    Taints: Prevent pods from being scheduled on certain nodes.

    Tolerations: Let pods "tolerate" those taints to be scheduled anyway.

### - Affinity & Anti-Affinity

    Affinity: Schedule pods together (e.g., frontend + backend).

    Anti-Affinity: Schedule pods apart for high availability.

### - Resource Requests and Limits

    Requests: Minimum resources a pod needs.

    Limits: Maximum it can use.

    Helps in fair distribution and performance management.

##  4. General Operations in Kubernetes

Operations include cluster setup, app management, and monitoring.
### - Control Plane Components

    API Server: Gateway to interact with the cluster.

    Scheduler: Assigns pods to nodes.

    Controller Manager: Watches and reconciles resource states.

    etcd: Stores all cluster data.

### - Nodes

    Where your containers actually run.

    Can be physical or virtual machines.

### - Deployments

    Manage application updates, scaling, and rollout.

    Creates and manages ReplicaSets.

### - ReplicaSets

    Ensures a specified number of pod replicas are running.

🔧 ConfigMaps

    Store non-sensitive configuration data for your pods.

📁 Volumes

    Provide persistent storage for pods (beyond pod lifecycle).

🔀 DaemonSets

    Ensures that a copy of a pod runs on every node (e.g., logging agent).

🕵️ StatefulSets

    For stateful apps (like databases) where identity and storage are important.

🛠️ Jobs & CronJobs

    Job: Run a task to completion (e.g., data migration).

    CronJob: Run tasks on a schedule (e.g., backups).

🧩 Bonus: Kubernetes Tools & Add-ons

    kubectl: CLI tool to manage cluster.

    Helm: Package manager for Kubernetes (like apt/yum but for K8s).

    Dashboard: Web UI to manage cluster resources visually.

    Metrics Server: Collects resource usage data (CPU/memory).

    Ingress Controller: Manages external access to services (via HTTP/S).








## ✅ Benefits of Using Kubernetes

- **Self-Healing**: Automatically restarts apps if they crash
- **Scalability**: Adds or removes containers based on usage
- **Rolling Updates**: Update apps without downtime
- **Load Balancing**: Shares traffic evenly
- **Portable**: Works on laptops, servers, or cloud
- **Secure**: Isolates and controls app communication
- **Declarative Configuration**: You describe what you want, Kubernetes does it

---





