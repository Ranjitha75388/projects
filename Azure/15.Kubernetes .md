# Kubernetes 

##  What is Kubernetes?

Kubernetes is an open-source container orchestration platform tool that helps to run, manage, and scale containerized apps automatically.

### Key Features:

-    Auto-Scaling: Adds or removes app instances based on traffic.

-   Load Balancing: Shares traffic across app copies.

-  Rolling Updates: Updates apps without downtime.

-   Self-Healing: Restarts crashed apps automatically.

-   Service Discovery: Makes apps find and talk to each other easily.


## 1. Kubernetes Architecture and Main Components

![image](https://github.com/user-attachments/assets/afa7f7be-c16a-4960-a057-dfa433aa3886)



##  Kubernetes Cluster Overview

A **Kubernetes cluster** is a group of computers that work together to run your containerized applications. These computers are divided into two main parts:

### 1. Control Plane (The Brain)

- This is the "brain" of the cluster — it manages the overall cluster.
- Typically, for **high availability**, a production cluster should have **at least 3 Control Plane nodes**, so if one fails, the others can continue managing the cluster.

### 2. Worker Nodes (The Workers)

- Actual computers that run the apps
- They get instructions from the Control Plane
- A cluster can have **1 or many worker nodes** based on the load


##  Control Plane Components

###  API Server

- Entry gate for all commands (like creating pods)
- Accepts commands from CLI (`kubectl`)
- Verifies and sends them to other components
- The only component that directly communicates with users

###  Scheduler

- Chooses the best worker node for new applications (Pods)
- Based on CPU, RAM, and availability
- Decides placement of new Pods

###  Controller Manager

- Watches the cluster and ensures the desired state is met.
- If a pod crashes, it recreates it
- Manages different controllers:
  - Node controller (checks if nodes are healthy)
  - Replication controller (manages replica pods)
  - Endpoints controller (joins services & pods)

###  etcd (Cluster Database)

- A simple key-value store
- Stores all the cluster information (like configurations data, pod status,secrets, and cluster state).

## Worker Node Components 

### Node

- A machine in the cluster
- Runs apps (pods) given by the Control Plane

### Pod

- A wrapper around one or more containers placed in nodes.


### Container Runtime

- Software responsible for running containers (e.g., Docker, containerd).
- Pulls container images and runs them

### kubelet

- Agent that runs on every worker node.
- Talks to Control Plane
- Tells the node what to do (start pod, stop pod)
- Ensures containers described in PodSpec are running

### kube-proxy

- Handles network rules on each node.

- Manages pod-to-pod and pod-to-service communication.

## Summary Table

| Component          | Role                                |
| ------------------ | ----------------------------------- |
| Cluster            | Group of machines running apps      |
| Node               | A single computer in the cluster    |
| Pod                | The smallest unit (runs containers) |
| Container          | The actual app                      |
| Control Plane      | The manager of everything           |
| API Server         | Entry point for commands            |
| Scheduler          | Picks best node for a pod           |
| Controller Manager | Maintains desired state             |
| etcd               | Stores current state                |
| Kubelet            | Runs on each node                   |
| Kube Proxy         | Directs traffic inside cluster      |


## 2. Ways to Set Up a Kubernetes Cluster

### 1.Kubernetes Playground

-  A free, browser-based Kubernetes cluster for practice. No install needed.
- **Pros:**
   - No need to install anything

  - Works on any device (even phones/tablets)

  - Great for learning and practice

  - Completely free
- **Cons:**

    - Temporary (resets after session)

    - No customization or scaling

    - Not for real apps

- **How to Use:**

    - Go to: https://killercoda.com/playgrounds

    - Click on “Kubernetes Playground”

    - Click “Start Playground”

    - Use the terminal to try:

    ```
    kubectl get nodes
    kubectl create deployment nginx --image=nginx
    kubectl get pods
    ```
### 2.Manual Setup (Kubernetes The Hard Way)

 -  Install and configure each Kubernetes component manually (API Server, Controller Manager, etc.)
 
 - **pros**

   - You learn exactly how Kubernetes works

   - Full control over every part of the setup

- **cons**

    - Very hard and time-consuming

    - Easy to make mistakes

    - Not ideal for real production use

 - **Steps:**

    - Create VMs or cloud machines (1 master + workers)

    - Install etcd (Kubernetes database)

    - Install Kubernetes parts: API server, scheduler, controller

    - Install kubelet and kube-proxy on workers

    - Set up TLS certificates and network plugin (like Calico)

    - Connect everything together manually


 [](https://github.com/kelseyhightower/kubernetes-the-hard-way)
 
### 3.Minikube – Local Kubernetes on Your Laptop

- A tool to run Kubernetes on your own laptop — great for learning and testing.

- **pros**

    - Easy to start: Just a few commands and it’s running.

    - Great for developers: Perfect for learning and local testing.

    - Free & open-source: No cost, no limits.
- **Cons** 

    - Not for real use: Just for learning and development, not production.

    - Uses your system resources: Needs decent CPU and RAM.

- **Step by step to Install Minikube**

  #### 1.Install kubectl on Linux

  Step 1: Download the latest release
  ```
  curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
  ```
  Step 2: Make the file executable
  ```
  chmod +x kubectl
  ```
  Step 3: Move the binary to your path
  ```
  sudo mv kubectl /usr/local/bin/
  ```
  Step 4: Verify installation
  ```
  kubectl version --client
  ```
  ![image](https://github.com/user-attachments/assets/4f88d611-910d-4ff9-b16d-1eb4a2ca44f8)

  #### 2.Install Minikube

  ```
  curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
  sudo install minikube-linux-amd64 /usr/local/bin/minikube
  ```
  #### 3.Start Minikube:
  ```
  minikube start
  ```
  ![image](https://github.com/user-attachments/assets/76452a7f-ac63-43b6-a775-58313695d42a)

  #### 4.Check if your cluster is running:
  ```
  kubectl get nodes
  ```
  ![image](https://github.com/user-attachments/assets/62e39ead-a394-4a88-aa0d-2d233f774b56)

### 4.Using Kubeadm (Semi-Automated Setup):

-  Kubeadm is a tool that helps you install a real Kubernetes cluster.
  
- It sets up the control plane (master) and lets you add worker nodes.

- **Pros**

    - **Full Control**: You decide what to install and how.

    - **Real Kubernetes**: It sets up the actual, full Kubernetes system used in big companies.

    - **Supports Everything**: You can add networking, storage, and other features you need.

    -  **Multi-node Setup:** You can connect multiple machines to create a larger, stronger cluster.

    - **Secure**: Automatically sets up encryption for secure communication.

    - **Good for Learning**: Helps you understand how Kubernetes really works behind the scenes.

- **Cons**

    - **Manual Setup:** You have to install and configure everything yourself (no easy wizard).

    - **Needs More Machines**: Best when you use 2+ machines, not just 1 (even if using VMs).

    - **No Built-in Dashboard**: You have to install a UI (like the Kubernetes Dashboard) separately if you want it.

    - **More Work**: You’ll need to handle updates, backups, and other maintenance tasks yourself.

- **Steps to Install with Kubeadm**
  
  **Step 1: Prepare your nodes (VMs or servers)**

     Minimum: 1 master + 1 worker

   **Step 2: Install kubeadm, kubelet, kubectl**
    ```
    sudo apt-get update
    sudo apt-get install -y apt-transport-https ca-certificates curl
    curl -fsSLo /usr/share/keyrings/kubernetes-archive-keyring.gpg https://packages.cloud.google.com/apt/doc/apt-key.gpg
    echo "deb [signed-by=/usr/share/keyrings/kubernetes-archive-keyring.gpg] https://apt.kubernetes.io/ kubernetes-xenial main" | sudo tee /etc/apt/sources.list.d/kubernetes.list
    sudo apt-get update
    sudo apt-get install -y kubelet kubeadm kubectl
    sudo apt-mark hold kubelet kubeadm kubectl
    ```
  **Step 3: Install container runtime (Docker or containerd)**

    (Example below uses Docker)
    ```
    sudo apt-get remove -y docker docker.io containerd runc
    sudo apt-get install -y ca-certificates curl gnupg lsb-release
    sudo mkdir -p /etc/apt/keyrings
    curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
    echo \
    "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
    $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
    sudo apt-get update
    sudo apt-get install -y docker-ce docker-ce-cli containerd.io
    ```
  **Step 4: Initialize Master Node**
    ```
    sudo kubeadm init
    ```
  **Step 5: Configure kubectl access**
    ```
    mkdir -p $HOME/.kube
    sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
    sudo chown $(id -u):$(id -g) $HOME/.kube/config
    ```
  **Step 6: Install CNI plugin (networking)**

    Example using Weave:
    ```
    kubectl apply -f "https://cloud.weave.works/k8s/net?k8s-version=$(kubectl version | base64 | tr -d '\n')"
    ```
  **Step 7: Join worker nodes**

    Run the **kubeadm join** command shown in Step 4 on your worker nodes.

### 3.Using Managed Kubernetes Services (Cloud-Managed Kubernetes):

 -   Cloud providers like AWS (EKS), Azure (AKS), and Google Cloud (GKE) offer **fully-managed Kubernetes** services.

 - **pros**
   
    1.**Production-Ready**: Suitable for real-world company projects; trusted by many businesses.
   
    2.**Cloud Manages Control Plane**:No need to install or maintain Kubernetes core components (like API server, etcd) — cloud handles it.
   
    3.**Fully Managed Control Plane**: Cloud provider automatically manages upgrades, patches, backups, and ensures high availability.
   
    4.**Very Easy Setup**: Create a Kubernetes cluster in just a few clicks or simple CLI commands.

    5.**Built-in Security**: Supports Identity integrations (like Azure AD), RBAC (Role-Based Access Control), and secrets management.

    6.**Auto Scaling** : Cluster can automatically scale pods or nodes based on CPU, memory, or custom metrics.

    7.**Monitoring & Logs Available** : Use tools like Azure Monitor, CloudWatch, or Stackdriver to see cluster and app health.

    8.**CI/CD Integration** : Easily connect to GitHub, Azure DevOps, Jenkins, and other pipelines for automatic deployments.

    9.**Simple Rolling Updates** : Update Kubernetes versions or applications without downtime.

    10.**Pay Only for Worker Nodes**: You only pay for the VMs (nodes); the control plane is free (like in AKS).

    11.**High Availability and Disaster Recovery** : Control plane spread across multiple zones for maximum uptime and resilience.
   
    12.**Expert Cloud Support**: Professional help is available from the cloud provider if anything goes wrong.
   
- **Cons**

    1.**Less Control**: You cannot deeply customize the Kubernetes internal settings (like etcd tuning, kube-apiserver flags).

    2.**Cloud Account Required**: Need to create and maintain a cloud account with Azure, AWS, or Google Cloud.

    3.**Costs Can Be High:** Running clusters 24/7 can get expensive if not properly managed.(Example: AWS EKS ~$73/month for control plane, though AKS is free.)

    4.**Vendor Lock-In Risk** : moving Kubernetes clusters between different clouds is not easy (AWS to Azure, etc.).

    5.**Not Fully Maintainable**:If you create clusters manually (via console or basic CLI), it's hard to track and re-create exactly unless you use automation tools (like Terraform).

- **Basic Steps to Use AKS**

1.Install Azure CLI
  ```
   curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash
  ```

2.Login to Azure:
  ```
   az login
  ```
3.Create a Resource Group:
  ```
  az group create --name myResourceGroup --location eastus
  ```
4.Create AKS Cluster:
  ```
  az aks create --resource-group myResourceGroup --name myAKSCluster --node-count 2
  ```
5.Install kubectl (Kubernetes CLI)
  ```
  az aks install-cli
  ```
6.Connect to AKS:
  ```
  az aks get-credentials --resource-group myResourceGroup --name myAKSCluster
  ```
  ![image](https://github.com/user-attachments/assets/6e785671-ad74-4c30-8f95-fe43240ce8c7)

7.Add public-ip in azure portal

  Add public-ip to cluster in Azure portal. kubernetes services > cluster > Networking > Manage > ip >  save.
  ```
  curl -s https://ifconfig.me
  ```
8.Create simple yaml file using pods.
  ```
  nano simple-pod.yaml
  ```
- Add the following file
  
```
apiVersion: v1
kind: Pod
metadata:
  name: nginx
spec:
  containers:
  - name: nginx
    image: nginx:1.14.2
    ports:
    - containerPort: 80
```

9.Deploy Applications
  ```
  kubectl apply -f simple-pod.yaml
  ```
  ![image](https://github.com/user-attachments/assets/a5a7aa18-cc7a-4f9c-8ca1-5b86dff242b1)

9.Monitor and Scale
  ```
  kubectl get pods
  kubectl logs pod-name
  kubectl scale deployment my-app --replicas=5
  ```
  ![image](https://github.com/user-attachments/assets/07318a56-dda8-409c-8a77-ef51d06c25a9)

## Common Kubectl Commands

| Action         | Command                       |
| -------------- | ----------------------------- |
| List Pods      | `kubectl get pods`            |
| List Nodes     | `kubectl get nodes`           |
| List Services  | `kubectl get services`        |
| Describe a Pod | `kubectl describe pod <name>` |
| Delete a Pod   | `kubectl delete pod <name>`   |
| Get All Resources | `kubectl get all`         |


## 4. Categorized Kubernetes Concepts

### 1. Cluster Management Concepts

These concepts help you manage the overall cluster.

  -  Cluster: A set of machines (nodes) running Kubernetes, where you deploy your workloads.

  -  Node: A machine (physical or virtual) running Kubernetes and hosting your containers.

  -  Master Node (Control Plane): The brain of the cluster that manages and controls the cluster, including components like API Server, Scheduler, Controller Manager, etc.

  -  Worker Node: A machine where application containers run, managed by the master node.

2. Core Kubernetes Concepts (Objects)

These are the basic building blocks of Kubernetes that define and manage applications.

    Pod: The smallest deployable unit in Kubernetes, usually a single container or multiple containers that share resources like network and storage.

    ReplicaSet: Ensures a specified number of identical Pods are running at any time.

    Deployment: Manages the lifecycle of Pods and ReplicaSets, including scaling, updating, and rolling back.

    StatefulSet: Similar to Deployments but designed for managing stateful applications (e.g., databases).

    DaemonSet: Ensures that a copy of a Pod runs on every node (or selected nodes) in the cluster.

    Job: A task that runs to completion, like batch processing or one-time tasks.

    CronJob: A Job that runs at scheduled times, similar to cron jobs in Unix/Linux.

3. Networking Concepts

These concepts manage communication between Pods and outside the cluster.

    Service: A logical abstraction that defines how to access Pods. It creates stable network access (IP & DNS) for Pods.

    ClusterIP: The default Service type, which provides an internal IP to access services inside the cluster.

    NodePort: Exposes a Service on a specific port of every Node, accessible externally.

    LoadBalancer: Automatically provisions a cloud load balancer to expose a service externally.

    Ingress: Manages external HTTP(S) access to services, typically with features like load balancing and SSL termination.

4. Storage Concepts

Kubernetes uses these to manage storage for your applications.

    Volume: A storage resource used by Pods to persist data.

    Persistent Volume (PV): A piece of storage in the cluster that is provisioned by an administrator.

    Persistent Volume Claim (PVC): A request for storage by a user or application.

    StorageClass: Defines different types of storage (e.g., SSD, HDD) and how they are provisioned dynamically.

5. Configuration & Secrets Management

These concepts help manage sensitive data and application configuration.

    ConfigMap: Stores non-sensitive configuration data that Pods can use.

    Secret: Stores sensitive information like passwords, tokens, or keys in an encrypted form.

    Environment Variables: Used to provide dynamic configuration to Pods or Containers.

6. Scheduling & Resource Management

These help control how resources are allocated and Pods are scheduled.

    Scheduler: Decides which Node a Pod will run on based on available resources.

    Resource Requests and Limits: Specify how much CPU and memory a container needs (requests) and the maximum it can consume (limits).

    Affinity and Anti-Affinity: Rules that control how Pods are scheduled in relation to other Pods.

    Taints and Tolerations: Prevent Pods from being scheduled on certain nodes unless they tolerate specific conditions.

7. Security & Access Control

These concepts help secure the cluster and control who can access it.

    Role-Based Access Control (RBAC): Manages user permissions in Kubernetes using roles and role bindings.

    ServiceAccount: Used by Pods to interact with the Kubernetes API server.

    Network Policies: Controls the network communication between Pods.

    PodSecurityPolicy (PSP): Defines security settings for Pods (though this is deprecated in Kubernetes 1.21 and replaced by OPA/Gatekeeper).

    Encryption at Rest: Ensures that sensitive data in the cluster (like Secrets) is encrypted when stored.

8. Monitoring & Logging

These concepts are used to monitor cluster health and gather logs.

    Metrics Server: Collects resource usage data (CPU, memory) from nodes and Pods.

    Prometheus: An open-source monitoring tool often used with Kubernetes to collect metrics.

    Grafana: A visualization tool often paired with Prometheus for dashboards.

    Logging (e.g., ELK Stack): Collects and stores logs for troubleshooting and performance analysis.

9. Scaling & Auto-scaling

These concepts help scale applications up and down based on load.

    Horizontal Pod Autoscaler (HPA): Automatically adjusts the number of Pods in a Deployment or ReplicaSet based on CPU or memory usage.

    Vertical Pod Autoscaler (VPA): Adjusts CPU and memory resources for Pods based on usage.

    Cluster Autoscaler: Adjusts the number of nodes in the cluster based on the resource requirements of Pods.

10. Helm (Package Management)

Helm is a tool for managing Kubernetes applications.

    Helm Chart: A package containing pre-configured Kubernetes resources (like Pods, Services, Deployments) for a specific application.

    Helm Repository: A place where Helm charts are stored and shared.

    Helm Release: An instance of a Helm chart running in your cluster.

11. Other Concepts

These are additional helpful concepts in Kubernetes.

    Namespace: A way to divide cluster resources into different virtual clusters, used for organizing applications.

    Kubelet: The agent that runs on each node and makes sure the containers are running as expected.

    Kube-Proxy: Maintains network rules for Pod communication.
