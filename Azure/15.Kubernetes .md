# Kubernetes 

##  What is Kubernetes?

Kubernetes is an open-source container orchestration platform tool that helps to run, manage, and scale containerized apps automatically.

### Key Features:

-    Auto-Scaling: Adds or removes app instances based on traffic.

-   Load Balancing: Shares traffic across app copies.

-  Rolling Updates: Updates apps without downtime.

-   Self-Healing: Restarts crashed apps automatically.

-   Service Discovery: Makes apps find and talk to each other easily.


## 1. Kubernetes Architecture and Main Components

![image](https://github.com/user-attachments/assets/afa7f7be-c16a-4960-a057-dfa433aa3886)



##  Kubernetes Cluster Overview

A **Kubernetes cluster** is a group of computers that work together to run your containerized applications. These computers are divided into two main parts:

### 1. Control Plane (The Brain)

- This is the "brain" of the cluster — it manages the overall cluster.
- Typically, for **high availability**, a production cluster should have **at least 3 Control Plane nodes**, so if one fails, the others can continue managing the cluster.

### 2. Worker Nodes (The Workers)

- Actual computers that run the apps
- They get instructions from the Control Plane
- A cluster can have **1 or many worker nodes** based on the load


##  Control Plane Components

###  API Server

- Entry gate for all commands (like creating pods)
- Accepts commands from CLI (`kubectl`)
- Verifies and sends them to other components
- The only component that directly communicates with users

###  Scheduler

- Chooses the best worker node for new applications (Pods)
- Based on CPU, RAM, and availability
- Decides placement of new Pods

###  Controller Manager

- Watches the cluster and ensures the desired state is met.
- If a pod crashes, it recreates it
- Manages different controllers:
  - Node controller (checks if nodes are healthy)
  - Replication controller (manages replica pods)
  - Endpoints controller (joins services & pods)

###  etcd (Cluster Database)

- A simple key-value store
- Stores all the cluster information (like configurations data, pod status,secrets, and cluster state).

## Worker Node Components 

### Node

- A machine in the cluster
- Runs apps (pods) given by the Control Plane

### Pod

- A wrapper around one or more containers placed in nodes.


### Container Runtime

- Software responsible for running containers (e.g., Docker, containerd).
- Pulls container images and runs them

### kubelet

- Agent that runs on every worker node.
- Talks to Control Plane
- Tells the node what to do (start pod, stop pod)
- Ensures containers described in PodSpec are running

### kube-proxy

- Handles network rules on each node.

- Manages pod-to-pod and pod-to-service communication.

## Summary Table

| Component          | Role                                |
| ------------------ | ----------------------------------- |
| Cluster            | Group of machines running apps      |
| Node               | A single computer in the cluster    |
| Pod                | The smallest unit (runs containers) |
| Container          | The actual app                      |
| Control Plane      | The manager of everything           |
| API Server         | Entry point for commands            |
| Scheduler          | Picks best node for a pod           |
| Controller Manager | Maintains desired state             |
| etcd               | Stores current state                |
| Kubelet            | Runs on each node                   |
| Kube Proxy         | Directs traffic inside cluster      |


## 2. Ways to Set Up a Kubernetes Cluster

### 1.Kubernetes Playground

-  A free, browser-based Kubernetes cluster for practice. No install needed.
- **Pros:**
   - No need to install anything

  - Works on any device (even phones/tablets)

  - Great for learning and practice

  - Completely free
- **Cons:**

    - Temporary (resets after session)

    - No customization or scaling

    - Not for real apps

- **How to Use:**

    - Go to: https://killercoda.com/playgrounds

    - Click on “Kubernetes Playground”

    - Click “Start Playground”

    - Use the terminal to try:

    ```
    kubectl get nodes
    kubectl create deployment nginx --image=nginx
    kubectl get pods
    ```
### 2.Manual Setup (Kubernetes The Hard Way)

 -  Install and configure each Kubernetes component manually (API Server, Controller Manager, etc.)
 
 - **pros**

   - You learn exactly how Kubernetes works

   - Full control over every part of the setup

- **cons**

    - Very hard and time-consuming

    - Easy to make mistakes

    - Not ideal for real production use

 - **Steps:**

    - Create VMs or cloud machines (1 master + workers)

    - Install etcd (Kubernetes database)

    - Install Kubernetes parts: API server, scheduler, controller

    - Install kubelet and kube-proxy on workers

    - Set up TLS certificates and network plugin (like Calico)

    - Connect everything together manually


 [](https://github.com/kelseyhightower/kubernetes-the-hard-way)
 
### 3.Minikube – Local Kubernetes on Your Laptop

- A tool to run Kubernetes on your own laptop — great for learning and testing.

- **pros**

    - Easy to start: Just a few commands and it’s running.

    - Great for developers: Perfect for learning and local testing.

    - Free & open-source: No cost, no limits.
- **Cons** 

    - Not for real use: Just for learning and development, not production.

    - Uses your system resources: Needs decent CPU and RAM.

- **Step by step to Install Minikube**

  #### 1.Install kubectl on Linux

  Step 1: Download the latest release
  ```
  curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
  ```
  Step 2: Make the file executable
  ```
  chmod +x kubectl
  ```
  Step 3: Move the binary to your path
  ```
  sudo mv kubectl /usr/local/bin/
  ```
  Step 4: Verify installation
  ```
  kubectl version --client
  ```
  ![image](https://github.com/user-attachments/assets/4f88d611-910d-4ff9-b16d-1eb4a2ca44f8)

  #### 2.Install Minikube

  ```
  curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
  sudo install minikube-linux-amd64 /usr/local/bin/minikube
  ```
  #### 3.Start Minikube:
  ```
  minikube start
  ```
  ![image](https://github.com/user-attachments/assets/76452a7f-ac63-43b6-a775-58313695d42a)

  #### 4.Check if your cluster is running:
  ```
  kubectl get nodes
  ```
  ![image](https://github.com/user-attachments/assets/62e39ead-a394-4a88-aa0d-2d233f774b56)

### 4.Using Kubeadm (Semi-Automated Setup):

-  Kubeadm is a tool that helps you install a real Kubernetes cluster.
  
- It sets up the control plane (master) and lets you add worker nodes.

- **Pros**

    - **Full Control**: You decide what to install and how.

    - **Real Kubernetes**: It sets up the actual, full Kubernetes system used in big companies.

    - **Supports Everything**: You can add networking, storage, and other features you need.

    -  **Multi-node Setup:** You can connect multiple machines to create a larger, stronger cluster.

    - **Secure**: Automatically sets up encryption for secure communication.

    - **Good for Learning**: Helps you understand how Kubernetes really works behind the scenes.

- **Cons**

    - **Manual Setup:** You have to install and configure everything yourself (no easy wizard).

    - **Needs More Machines**: Best when you use 2+ machines, not just 1 (even if using VMs).

    - **No Built-in Dashboard**: You have to install a UI (like the Kubernetes Dashboard) separately if you want it.

    - **More Work**: You’ll need to handle updates, backups, and other maintenance tasks yourself.

- **Steps to Install with Kubeadm**
  
  **Step 1: Prepare your nodes (VMs or servers)**

     Minimum: 1 master + 1 worker

   **Step 2: Install kubeadm, kubelet, kubectl**
    ```
    sudo apt-get update
    sudo apt-get install -y apt-transport-https ca-certificates curl
    curl -fsSLo /usr/share/keyrings/kubernetes-archive-keyring.gpg https://packages.cloud.google.com/apt/doc/apt-key.gpg
    echo "deb [signed-by=/usr/share/keyrings/kubernetes-archive-keyring.gpg] https://apt.kubernetes.io/ kubernetes-xenial main" | sudo tee /etc/apt/sources.list.d/kubernetes.list
    sudo apt-get update
    sudo apt-get install -y kubelet kubeadm kubectl
    sudo apt-mark hold kubelet kubeadm kubectl
    ```
  **Step 3: Install container runtime (Docker or containerd)**

    (Example below uses Docker)
    ```
    sudo apt-get remove -y docker docker.io containerd runc
    sudo apt-get install -y ca-certificates curl gnupg lsb-release
    sudo mkdir -p /etc/apt/keyrings
    curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
    echo \
    "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
    $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
    sudo apt-get update
    sudo apt-get install -y docker-ce docker-ce-cli containerd.io
    ```
  **Step 4: Initialize Master Node**
    ```
    sudo kubeadm init
    ```
  **Step 5: Configure kubectl access**
    ```
    mkdir -p $HOME/.kube
    sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
    sudo chown $(id -u):$(id -g) $HOME/.kube/config
    ```
  **Step 6: Install CNI plugin (networking)**

    Example using Weave:
    ```
    kubectl apply -f "https://cloud.weave.works/k8s/net?k8s-version=$(kubectl version | base64 | tr -d '\n')"
    ```
  **Step 7: Join worker nodes**

    Run the **kubeadm join** command shown in Step 4 on your worker nodes.

### 3.Using Managed Kubernetes Services (Cloud-Managed Kubernetes):

 -   Cloud providers like AWS (EKS), Azure (AKS), and Google Cloud (GKE) offer **fully-managed Kubernetes** services.

 - **pros**
   
    1.**Production-Ready**: Suitable for real-world company projects; trusted by many businesses.
   
    2.**Cloud Manages Control Plane**:No need to install or maintain Kubernetes core components (like API server, etcd) — cloud handles it.
   
    3.**Fully Managed Control Plane**: Cloud provider automatically manages upgrades, patches, backups, and ensures high availability.
   
    4.**Very Easy Setup**: Create a Kubernetes cluster in just a few clicks or simple CLI commands.

    5.**Built-in Security**: Supports Identity integrations (like Azure AD), RBAC (Role-Based Access Control), and secrets management.

    6.**Auto Scaling** : Cluster can automatically scale pods or nodes based on CPU, memory, or custom metrics.

    7.**Monitoring & Logs Available** : Use tools like Azure Monitor, CloudWatch, or Stackdriver to see cluster and app health.

    8.**CI/CD Integration** : Easily connect to GitHub, Azure DevOps, Jenkins, and other pipelines for automatic deployments.

    9.**Simple Rolling Updates** : Update Kubernetes versions or applications without downtime.

    10.**Pay Only for Worker Nodes**: You only pay for the VMs (nodes); the control plane is free (like in AKS).

    11.**High Availability and Disaster Recovery** : Control plane spread across multiple zones for maximum uptime and resilience.
   
    12.**Expert Cloud Support**: Professional help is available from the cloud provider if anything goes wrong.
   
- **Cons**

    1.**Less Control**: You cannot deeply customize the Kubernetes internal settings (like etcd tuning, kube-apiserver flags).

    2.**Cloud Account Required**: Need to create and maintain a cloud account with Azure, AWS, or Google Cloud.

    3.**Costs Can Be High:** Running clusters 24/7 can get expensive if not properly managed.(Example: AWS EKS ~$73/month for control plane, though AKS is free.)

    4.**Vendor Lock-In Risk** : moving Kubernetes clusters between different clouds is not easy (AWS to Azure, etc.).

    5.**Not Fully Maintainable**:If you create clusters manually (via console or basic CLI), it's hard to track and re-create exactly unless you use automation tools (like Terraform).

- **Basic Steps to Use AKS**

1.Install Azure CLI
  ```
   curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash
  ```

2.Login to Azure:
  ```
   az login
  ```
3.Create a Resource Group:
  ```
  az group create --name myResourceGroup --location eastus
  ```
4.Create AKS Cluster:
  ```
  az aks create --resource-group myResourceGroup --name myAKSCluster --node-count 2
  ```
5.Install kubectl (Kubernetes CLI)
  ```
  az aks install-cli
  ```
6.Connect to AKS:
  ```
  az aks get-credentials --resource-group myResourceGroup --name myAKSCluster
  ```
  ![image](https://github.com/user-attachments/assets/6e785671-ad74-4c30-8f95-fe43240ce8c7)

7.Add public-ip in azure portal

  Add public-ip to cluster in Azure portal. kubernetes services > cluster > Networking > Manage > ip >  save.
  ```
  curl -s https://ifconfig.me
  ```
8.Create simple yaml file using pods.
  ```
  nano simple-pod.yaml
  ```
- Add the following file
  
```
apiVersion: v1
kind: Pod
metadata:
  name: nginx
spec:
  containers:
  - name: nginx
    image: nginx:1.14.2
    ports:
    - containerPort: 80
```

9.Deploy Applications
  ```
  kubectl apply -f simple-pod.yaml
  ```
  ![image](https://github.com/user-attachments/assets/a5a7aa18-cc7a-4f9c-8ca1-5b86dff242b1)

9.Monitor and Scale
  ```
  kubectl get pods
  kubectl logs pod-name
  kubectl scale deployment my-app --replicas=5
  ```
  ![image](https://github.com/user-attachments/assets/07318a56-dda8-409c-8a77-ef51d06c25a9)

## Common Kubectl Commands

| Action         | Command                       |
| -------------- | ----------------------------- |
| List Pods      | `kubectl get pods`            |
| List Nodes     | `kubectl get nodes`           |
| List Services  | `kubectl get services`        |
| Describe a Pod | `kubectl describe pod <name>` |
| Delete a Pod   | `kubectl delete pod <name>`   |
| Get All Resources | `kubectl get all`         |


## 4. Categorized Kubernetes Concepts

### 1. Cluster Management

- **Cluster**	: A group of machines (nodes) where Kubernetes runs containerized apps.
- **Node**: A physical or virtual machine inside the cluster.
- **Master Node (Control Plane)**	: Brain of Kubernetes: API Server, Scheduler, etc., manages everything.
- **Worker Node**	:  Nodes that actually run your applications (containers).
- **Kubelet**	:  Agent that runs on every Node ,talks to the control plane,ensures containers are running.
- **Kube-Proxy**	:  Handles network routing for Pods inside a Node.

### 2. Core Kubernetes Objects

- **Pod**	:  The smallest deployable unit, a container (or group of containers) with shared network/storage.
- **ReplicaSet**	:  Ensures a specific number of Pods are running.
- **Deployment**	:  Manages ReplicaSets, updates apps safely (rolling updates, rollback).
- **StatefulSet**	:  Like Deployment, but for apps that need persistent storage and stable network IDs.
- **DaemonSet**	:  Run one Pod on every Node (for monitoring, networking, etc.).
- **Job**	:  Run a task once and stop when it's done.(one-time job)
- **CronJob**	:  Schedules Jobs to run at specific times, like a cron task.

### 3. Networking Concepts

- **Service**	:  Exposes a set of Pods with a stable IP/DNS name.
- **ClusterIP**:  Internal-only access for a Service inside the cluster.
- **NodePort**	:  Service is accessible from outside the cluster,Kubernetes opens a specific port (like 30000–32767) on every Node.connect (Node's IP address + NodePort number.)
- **LoadBalancer**	: Distributes external traffic across multiple Pods for high availability.
- **Ingress**	:  Lets outside traffic (HTTP/HTTPS) access apps inside the cluster.
- **Network Policy**	:  Controls allowed communication between Pods (firewall rules).
- **CNI** :  Plugins	Tools like Calico, Flannel for Kubernetes networking between Pods.

### 4. Storage Concepts

- **Volume**	: Storage ,that a Pod can use to save important data safe, even if the container stops and starts again.
- **ConfigMap**: Store non-secret configuration data(like app settings).
- **Secret**: Store sensitive info (like passwords,API keys).

### 5. Scheduling & Resource Management

- **Scheduler**	: Decides which Node will run which Pod.
- **Resource Requests**	: Minimum resources (CPU, Memory) a Pod needs.
- **Resource Limits**	: Maximum resources (CPU, Memory) a Pod can use.
- **Horizontal Pod Autoscaler (HPA)**	: Scales number of Pods based on CPU/Memory load.
- **Vertical Pod Autoscaler (VPA)**: Adjusts CPU/Memory allocations per Pod automatically.
- **Cluster Autoscaler**	: Adds/removes Nodes based on cluster needs.
- **Affinity/Anti-Affinity**	: Rules for scheduling Pods on specific Nodes or avoiding certain Nodes.
- **Taints & Tolerations**	: Forces Pods to run only on specific Nodes or avoid others.

### 6. Security Concepts

- **RBAC (Role-Based Access Control)**	: Controls which users or apps can access/manage inside Kubernetes.eg:User A can only view Pods, not delete them.
- **Role / ClusterRole**	: Role = permissions to view for one namespace(dev namespace).//ClusterRole = permissions to view all nodes inside whole cluster.
- **RoleBinding / ClusterRoleBinding**: RoleBinding: Grants a (Read) Role to a user, group, or service account inside one namespace.//ClusterRoleBinding:Grants a ClusterRole (admin) to a user, group, or  service account cluster-wide.
- **ServiceAccount**	: user identity for Pods.It’s used when Pods need to talk to Kubernetes API or other services securely.
- **Encryption at Rest**	: Data like Secrets are stored encrypted in etcd database.

### 7. Monitoring & Logging

- **Metrics Server**	: Collects basic resource metrics (CPU, memory) from Pods/Nodes.
- **Prometheus**	: powerfull and detailed metrics monitoring + stores those metrics in a database + alerting system.
- **Grafana** :	Takes data from Prometheus and shows it in beautiful dashboards as graphs, charts, and visual alerts.
- **Logging Stack (ELK/EFK)** :	Collects and manages logs for debugging and analysis.

### 8. Deployment and Scaling

Helm	Package manager for Kubernetes applications.
Helm Chart	A pre-configured Kubernetes resource bundle.
Helm Repository	Store Helm charts online.
Helm Release	A running instance of a Helm Chart inside the cluster.
Kubernetes Objects	Everything managed inside Kubernetes (Pods, Deployments, Services, etc.).
Namespace	Logical separation within a cluster (different teams, projects).
























