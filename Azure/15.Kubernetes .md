# Kubernetes

## What is Kubernetes?

Kubernetes is an open-source container orchestration platform that helps run, manage, and scale containerized applications automatically.

### Key Features:

- **Auto-Scaling**: Adds or removes app instances based on traffic.
- **Load Balancing**: Distributes traffic across app copies.
- **Rolling Updates**: Updates apps without downtime.
- **Self-Healing**: Restarts crashed apps automatically.
- **Service Discovery**: Enables apps to find and communicate with each other easily.

---

## 1. Kubernetes Architecture and Main Components

![image](https://github.com/user-attachments/assets/afa7f7be-c16a-4960-a057-dfa433aa3886)

### Kubernetes Cluster Overview

- A **Pod** is the smallest deployable unit in Kubernetes. It contains one or more app containers that are tightly coupled and share storage and networking resources.
- A **Node** is a single machine (physical or virtual) that runs one or more Pods.
- A **Kubernetes Cluster** is a group of Nodes working together to run containerized applications, divided into two main parts:

### 1. Control Plane (The Brain)
- Manages the overall cluster.
- In production, at least three Control Plane nodes are recommended for **high availability**.

### 2. Worker Nodes (The Workers)
- Run the actual apps (Pods).
- Follow instructions from the Control Plane.
- A cluster can have **one or many Worker Nodes**, depending on the load.

---

## Control Plane Components

### API Server
- The front door of the Kubernetes cluster.
- Accepts commands from CLI (`kubectl`) and communicates with other components.
- The only component that interacts directly with users.

### Scheduler
- Selects the best Worker Node for new Pods.
- Considers CPU, RAM, and resource availability.

### Controller Manager
- Watches the cluster and ensures the desired state is achieved.
- Recreates Pods if they crash.
- Manages various controllers:
  - Node controller
  - Replication controller
  - Endpoints controller

### etcd (Cluster Database)
- A highly available key-value store.
- Stores cluster data like configurations, secrets, and current cluster state.

---

## Worker Node Components

### Container Runtime
- Runs containers (e.g., Docker, containerd).
- Pulls and runs container images.

### kubelet
- Agent that runs on each Worker Node.
- Communicates with the Kubernetes Control Plane (specifically, the API Server).
- Receives instructions from the Control Plane (e.g., start a Pod, stop a Pod).
- Ensures that the containers described in the Pod specs are running and healthy as expected.
- If a container crashes or dies, kubelet can restart it based on the Pod’s definition.

### kube-proxy
- Handles network rules on each Node.
- Manages Pod-to-Pod and Pod-to-Service communication.

---

## 2. Categorized Kubernetes Concepts

1.Cluster Management

2.Deployment and Scaling

3.Networking Concepts

4.Storage Concepts

5.Scheduling & Resource Management

6.Security Concepts

7.Monitoring & Logging

### 1. Cluster Management
- **Cluster**: A group of Nodes running Kubernetes.
- **Node**: Physical/virtual machine inside the cluster.
- **Master Node (Control Plane)**: Brain of Kubernetes (API Server, Scheduler, etc.).
- **Worker Node**: Runs applications.
- **Kubelet**: Node agent ensuring containers are running.
- **Kube-proxy**: Handles networking inside Nodes.

### 2. Deployment and Scaling
- **Pod**: Smallest deployable unit (one or more containers).
- **ReplicaSet**: Ensures the correct number of Pods are running.
- **Deployment**: Manages ReplicaSets and rolling updates.
- **StatefulSet**: Like Deployment, but for apps needing persistent storage,stable network identity.
- **DaemonSet**: Ensures one Pod per Node (e.g., monitoring agents).
- **Job**: Run a task once and stop when it's done.(one-time job)
- **CronJob**: Schedules Jobs to run at specific times, like a cron task.
- **Namespace**: Logical seperation with in a cluster (e.g., dev/test/prod).

### 3. Networking Concepts
- **Service**: Exposes Pods with a stable IP/DNS.
- **ClusterIP**: Internal-only service access.
- **NodePort**: External access via specific Node ports (30000–32767).
- **LoadBalancer**: Exposes services externally with a cloud load balancer.
- **Ingress**: Lets outside traffic (HTTP/HTTPS) access apps inside the cluster.
- **Network Policy**: Controls Pod communication (firewall rules).
- **CNI Plugins**: Manage networking between Pods (e.g., Calico, Flannel).

### 4. Storage Concepts
- **Volume**: Persistent storage for Pods.
- **ConfigMap**: Stores non-sensitive configuration data.
- **Secret**: Stores sensitive information securely (passwords, API keys).

### 5. Scheduling & Resource Management
- **Scheduler**: Assigns Pods to Nodes.
- **Resource Requests**: Minimum resources a Pod needs.
- **Resource Limits**: Maximum resources a Pod can use.
- **Horizontal Pod Autoscaler (HPA)**: Scales Pods horizontally based on metrics.
- **Vertical Pod Autoscaler (VPA)**: Adjusts resource requests for Pods.
- **Cluster Autoscaler**: Adds/removes Nodes automatically.
- **Affinity/Anti-Affinity**: Rules for scheduling Pods on specific Nodes or avoiding certain Nodes.
- **Taints & Tolerations**:Forces Pods to run only on specific Nodes or avoid others.

### 6. Security Concepts
- **RBAC**: Controls access permissions.(eg:User A can only view Pods, not delete them).
- **Role / ClusterRole**: Permissions to view for one namespace(dev namespace).// permissions to view all nodes inside whole cluster.
- **RoleBinding / ClusterRoleBinding**: Grants a (Read) Role to a user, group, or service account inside one namespace.//Grants a ClusterRole (admin) to a user, group, or service account cluster-wide.
- **ServiceAccount**: User identity for Pods.It’s used when Pods need to talk to Kubernetes API or other services securely.
- **Encryption at Rest**: Encrypts sensitive data in etcd.

### 7. Monitoring & Logging
- **Metrics Server**: Collects basic resource metrics (CPU, memory) from Pods/Nodes.
- **Prometheus**: Detailed monitoring and alerting system.
- **Grafana**: Dashboards and visualizations for Prometheus data as graphs, charts, and visual alerts.
- **Logging Stack (ELK/EFK)**: Collects and manages logs for debugging and analysis.

---

## 3. Ways to Set Up a Kubernetes Cluster

### 1. Kubernetes Playground
- Free, browser-based Kubernetes clusters.
- **Pros**: No installation, easy access, great for learning.
- **Cons**: Temporary sessions, no real apps, no customization.

#### How to Use:
- Visit: [KillerCoda Kubernetes Playground](https://killercoda.com/playgrounds)
- Start the playground and practice basic commands:
  ```
  kubectl get nodes
  kubectl create deployment nginx --image=nginx
  kubectl get pods
  ```

---

### 2. Manual Setup (Kubernetes the Hard Way)
- Manually set up each Kubernetes component.
- **Pros**: Deep learning and full control.
- **Cons**: Complex, easy mistakes done, time-consuming.

[Guide: Kubernetes the Hard Way](https://github.com/kelseyhightower/kubernetes-the-hard-way)

---

### 3. Minikube – Local Kubernetes

- Run Kubernetes locally on your laptop.
- **Pros**: Quick to start, great for development.
- **Cons**: Limited to local testing, uses local resources.

#### Install Minikube (Linux example):

1. Install `kubectl`:
    ```
    curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
    chmod +x kubectl
    sudo mv kubectl /usr/local/bin/
    kubectl version --client
    ```
     ![image](https://github.com/user-attachments/assets/4c410c57-1575-4a32-9b48-7acb69ebed5d)

2. Install Minikube:
    ```
    curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
    sudo install minikube-linux-amd64 /usr/local/bin/minikube
    ```
3. Start Minikube:
    ```
    minikube start
    ```
     ![image](https://github.com/user-attachments/assets/7fc035c2-5018-40da-9167-1e94546c9e8d)

4. Verify cluster:
    ```
    kubectl get nodes
    ```
     ![image](https://github.com/user-attachments/assets/3f33a8c8-52d9-42ea-a484-9c3acc5539ae)

---

### 4. Using Kubeadm (Semi-Automated Setup)

- Helps you set up a real Kubernetes cluster easily.
- **Pros**: Real production-ready setup.
- **Cons**: Requires multiple machines and manual networking setup.

#### Basic Steps:

1. Install `kubeadm`, `kubelet`, `kubectl`:
    ```
    sudo apt-get update
    sudo apt-get install -y apt-transport-https ca-certificates curl
    curl -fsSLo /usr/share/keyrings/kubernetes-archive-keyring.gpg https://packages.cloud.google.com/apt/doc/apt-key.gpg
    echo "deb [signed-by=/usr/share/keyrings/kubernetes-archive-keyring.gpg] https://apt.kubernetes.io/ kubernetes-xenial main" | sudo tee /etc/apt/sources.list.d/kubernetes.list
    sudo apt-get update
    sudo apt-get install -y kubelet kubeadm kubectl
    sudo apt-mark hold kubelet kubeadm kubectl
    ```
2. Install Docker:
    ```
    sudo apt-get install -y docker-ce docker-ce-cli containerd.io
    ```
3. Initialize the master:
    ```
    sudo kubeadm init
    ```
4. Configure `kubectl`:
    ```
    mkdir -p $HOME/.kube
    sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
    sudo chown $(id -u):$(id -g) $HOME/.kube/config
    ```
5. Install CNI (e.g., Weave):
    ```
    kubectl apply -f "https://cloud.weave.works/k8s/net?k8s-version=$(kubectl version | base64 | tr -d '\n')"
    ```
6. Join worker nodes with `kubeadm join`.

---

### 5. Managed Kubernetes (Cloud Services)

Cloud providers offer Kubernetes as a Service:

| Provider  | Service |
|-----------|---------|
| AWS       | EKS     |
| Azure     | AKS     |
| Google    | GKE     |

### **Pros**:

1.**Production-Ready**: Suitable for real-world company projects; trusted by many businesses.

2.**Cloud Manages Control Plane**:No need to install or maintain Kubernetes core components (like API server, etcd) — cloud handles it.

3.**Fully Managed Control Plane**: Cloud provider automatically manages upgrades, patches, backups, and ensures high availability.

4.**Very Easy Setup:** Create a Kubernetes cluster in just a few clicks or simple CLI commands.

5.**Built-in Security:** Supports Identity integrations (like Azure AD), RBAC (Role-Based Access Control), and secrets management.

6.**Auto Scaling :** Cluster can automatically scale pods or nodes based on CPU, memory, or custom metrics.

7.**Monitoring & Logs Available :** Use tools like Azure Monitor, CloudWatch, or Stackdriver to see cluster and app health.

8.**CI/CD Integration :** Easily connect to GitHub, Azure DevOps, Jenkins, and other pipelines for automatic deployments.

9.**Simple Rolling Updates :** Update Kubernetes versions or applications without downtime.

10.**Pay Only for Worker Nodes:** You only pay for the VMs (nodes); the control plane is free (like in AKS).

11.**High Availability and Disaster Recovery :** Control plane spread across multiple zones for maximum uptime and resilience.

12.**Expert Cloud Support:** Professional help is available from the cloud provider if anything goes wrong.

### **Cons**:

1.**Less Control:** You cannot deeply customize the Kubernetes internal settings (like etcd tuning, kube-apiserver flags).

2.**Cloud Account Required:** Need to create and maintain a cloud account with Azure, AWS, or Google Cloud.

3.**Costs Can Be High:** Running clusters 24/7 can get expensive if not properly managed.(Example: AWS EKS ~$73/month for control plane, though AKS is free.)

4.**Vendor Lock-In Risk :** moving Kubernetes clusters between different clouds is not easy (AWS to Azure, etc.).

5.**Not Fully Maintainable**:If you create clusters manually (via console or basic CLI), it's hard to track and re-create exactly unless you use automation tools (like Terraform).

---

## Steps to Access AKS

1.Install Azure CLI
  ```
   curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash
  ```

2.Login to Azure:
  ```
   az login
  ```
3.Create a Resource Group:
  ```
  az group create --name myResourceGroup --location eastus
  ```
4.Create AKS Cluster:
  ```
  az aks create --resource-group myResourceGroup --name myAKSCluster --node-count 2
  ```
5.Install kubectl (Kubernetes CLI)
  ```
  az aks install-cli
  ```
6.Connect to AKS:
  ```
  az aks get-credentials --resource-group myResourceGroup --name myAKSCluster
  ```
  ![image](https://github.com/user-attachments/assets/6e785671-ad74-4c30-8f95-fe43240ce8c7)

7.Add public-ip in azure portal

  Add public-ip to cluster in Azure portal. kubernetes services > cluster > Networking > Manage > ip >  save.
  ```
  curl -s https://ifconfig.me
  ```
8.Create simple yaml file to create pods.
  ```
  nano simple-pod.yaml
  ```
- Add the following file
  
```
apiVersion: v1
kind: Pod
metadata:
  name: nginx
spec:
  containers:
  - name: nginx
    image: nginx:1.14.2
    ports:
    - containerPort: 80
```

9.Deploy Applications
  ```
  kubectl apply -f simple-pod.yaml
  ```
  ![image](https://github.com/user-attachments/assets/a5a7aa18-cc7a-4f9c-8ca1-5b86dff242b1)

9.Monitor and Scale
  ```
  kubectl get pods
  kubectl logs pod-name
  kubectl scale deployment my-app --replicas=5
  ```
  ![image](https://github.com/user-attachments/assets/07318a56-dda8-409c-8a77-ef51d06c25a9)

#### kubectl → API Server → etcd → Scheduler → Node (kubelet) → Container runtime → Pod running 

---

## Create yaml_file Creating a Deployment

```
  nano deployment.yaml
```
- The following is an example of a Deployment. It creates a ReplicaSet to bring up three nginx Pods:

```
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
  labels:
    app: nginx
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.14.2
        ports:
        - containerPort: 80
```
- Create the Deployment by running the following command
    ```
     kubectl apply -f deployment.yaml
    ```
    ![image](https://github.com/user-attachments/assets/61ff3185-6f1d-4b3a-b2a7-a3e022dd1195)

- Run the following command to check Deployment has created all three replicas, and all replicas are up-to-date (they contain the latest Pod template) and available.
  ```
   kubectl get deployments
  ```
    ![image](https://github.com/user-attachments/assets/96c8ba9c-2a94-4e14-a607-af034923a864)

- To see the ReplicaSet (rs) created by the Deployment
  ```
   kubectl get rs
  ```
    ![image](https://github.com/user-attachments/assets/dda317df-5d93-429d-830e-38d9224f3bc2)

- To see the labels automatically generated for each Pod
  ```
   kubectl get pods --show-labels
  ```
   ![image](https://github.com/user-attachments/assets/79327ab2-9235-4de3-8a27-8c07e53e2700)

- To see the rollout status
  ```
   kubectl rollout status deployment/nginx-deployment
  ```
- Get details of our Deployment
  ```
   kubectl describe deployments
  ```
    ![image](https://github.com/user-attachments/assets/c7aeb0b8-4de4-4d8e-b4f0-4b1bfc0a2e5d)

### Simple Architecture Flow Diagram 

User (kubectl) --> API Server --> etcd (stores Deployment) --> Deployment Controller (creates ReplicaSet) --> etcd (stores ReplicaSet) --> ReplicaSet Controller (creates Pods) --> etcd (stores Pods) --> Scheduler (assigns Node to Pods) --> kubelet (on Node starts Pods) --> container Runtime (runs containers)


---

## Common `kubectl` Commands

| Action                | Command                                       |
|------------------------|-----------------------------------------------|
| List Nodes             | `kubectl get nodes`                          |
| List Pods              | `kubectl get pods`                           |
| Create Deployment      | `kubectl create deployment nginx --image=nginx` |
| Scale Deployment       | `kubectl scale deployment nginx --replicas=5` |
| View Logs              | `kubectl logs <pod-name>`                    |
| Apply Config File      | `kubectl apply -f <file>.yaml`               |
| Delete Resource        | `kubectl delete <resource> <name>`           |
| View Cluster Info      | `kubectl cluster-info`                       |

